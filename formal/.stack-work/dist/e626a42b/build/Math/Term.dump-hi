
==================== FINAL INTERFACE ====================
2020-01-31 15:56:28.7008564 UTC

interface formal-types-0.0.0.1-LNuWVcA3B6I9n93ajhqv14:Math.Term 8065
  interface hash: c401ff14a51526710c93467dd9f7ea16
  ABI hash: 1c8b969b4f924801beda1467f164f610
  export-list hash: 5805c965562f3eaa10032d3b77582407
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: ef450f4f570fadc561af483b4f3bcc35
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Math.Term.-->
  Math.Term..$
  Math.Term..:
  Math.Term..=
  Math.Term.addTypes
  Math.Term.alpha
  Math.Term.alphaReduce
  Math.Term.anyCoprod
  Math.Term.anyInhabOf
  Math.Term.applyDefs
  Math.Term.applyMatches
  Math.Term.applyMorphs
  Math.Term.assocLaw0
  Math.Term.assocLaw1
  Math.Term.beta
  Math.Term.binary
  Math.Term.bind
  Math.Term.boundVars
  Math.Term.coprod
  Math.Term.coprodType
  Math.Term.ctx0
  Math.Term.ctx1
  Math.Term.ctxEmp
  Math.Term.defConst
  Math.Term.depth
  Math.Term.derive
  Math.Term.emptyMT
  Math.Term.equivdef
  Math.Term.equivs
  Math.Term.false2
  Math.Term.freeVars
  Math.Term.funcComp
  Math.Term.funcElim
  Math.Term.funcToInd
  Math.Term.funcType
  Math.Term.getDefSubs
  Math.Term.getRelated
  Math.Term.getRelations
  Math.Term.ident
  Math.Term.identityFunctorLaw1
  Math.Term.identityFunctorLaw2
  Math.Term.indMorph
  Math.Term.indPattern
  Math.Term.indToFunc
  Math.Term.indToTree
  Math.Term.indX
  Math.Term.induct
  Math.Term.inductionTree
  Math.Term.inductors
  Math.Term.inhabOne
  Math.Term.inl
  Math.Term.inr
  Math.Term.insertAllMT
  Math.Term.insertMT
  Math.Term.intro
  Math.Term.introRules
  Math.Term.intros
  Math.Term.isMemberOf
  Math.Term.lambdaInductor
  Math.Term.lambdaType
  Math.Term.metaType
  Math.Term.nat
  Math.Term.natnum
  Math.Term.newIdents
  Math.Term.newType
  Math.Term.newTypes
  Math.Term.numnat
  Math.Term.one
  Math.Term.oneInductor
  Math.Term.pair
  Math.Term.pairType
  Math.Term.pathInduction
  Math.Term.piCons
  Math.Term.piCoprodComp
  Math.Term.piInductor1
  Math.Term.piInductor2
  Math.Term.piInductor3
  Math.Term.piInductor4
  Math.Term.piSigmaComp
  Math.Term.piType
  Math.Term.prjLInd
  Math.Term.prjMatchL
  Math.Term.prjMatchLComp
  Math.Term.prjMatchR
  Math.Term.prjMatchRComp
  Math.Term.prjRInd
  Math.Term.prjl
  Math.Term.prjr
  Math.Term.processList
  Math.Term.pureSub
  Math.Term.refl
  Math.Term.reflElim
  Math.Term.reflectLaw
  Math.Term.relation
  Math.Term.setconcat
  Math.Term.showMatches
  Math.Term.sigmaComp1
  Math.Term.sigmaCons
  Math.Term.sigmaInductor1
  Math.Term.sigmaInductor2
  Math.Term.sigmaInductor3
  Math.Term.sigmaType
  Math.Term.subscript
  Math.Term.substitution
  Math.Term.subtypes
  Math.Term.successor
  Math.Term.supertypes
  Math.Term.toIdInd
  Math.Term.true2
  Math.Term.two
  Math.Term.typeInductor
  Math.Term.typeReduce
  Math.Term.typeTheory
  Math.Term.unary
  Math.Term.uniquejoin
  Math.Term.uniquesTree
  Math.Term.wild
  Math.Term.wildcard
  Math.Term.zero
  Math.Term.zeroInductor
  Math.Term.|->
  Math.Term.Context{Math.Term.Ctx}
  Math.Term.InductionTree{Math.Term.Node Math.Term.Null}
  Math.Term.Inductor{Math.Term.Inductor}
  Math.Term.PrimConst{Math.Term.Coprod Math.Term.DefConst Math.Term.DefEq Math.Term.DefType Math.Term.Func Math.Term.Ident Math.Term.Inl Math.Term.Inr Math.Term.Nat Math.Term.One Math.Term.Pair Math.Term.Pi Math.Term.Prjl Math.Term.Prjr Math.Term.Refl Math.Term.Sigma Math.Term.Two Math.Term.Zero}
  Math.Term.Term{Math.Term.Ap Math.Term.Def Math.Term.Lambda Math.Term.Prim Math.Term.U Math.Term.X}
  Math.Term.TypeRel{Math.Term.EQUIV Math.Term.NOTEQ Math.Term.SUBTYPE Math.Term.SUPERTYPE}
module dependencies:
package dependencies: array-0.5.3.0 base-4.12.0.0*
                      containers-0.6.0.1* deepseq-1.4.4.0 ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
import  -/  base-4.12.0.0:Control.Applicative 5d23933516d8709a12bd090130e91420
import  -/  base-4.12.0.0:Data.Foldable bdeac546b12282c8986759606b9295a5
import  -/  base-4.12.0.0:Data.List 6c60559263db7cf0f22549b9673785b9
import  -/  base-4.12.0.0:Data.Semigroup 9f39c894c4dbf13d5d60bc928db091a9
import  -/  base-4.12.0.0:GHC.Base fbe365a916ebeeeb4bc1f895dbe83e42
import  -/  base-4.12.0.0:GHC.Err 3a680f55541fe399f95f794018fc3593
import  -/  base-4.12.0.0:GHC.List bb56c56a8dc21963b5824914872db158
import  -/  base-4.12.0.0:GHC.Num 8203d3fee487126cffd5e55ba5d0e8c3
import  -/  base-4.12.0.0:GHC.Real 3b42f3125c1d17d4e4b4437a3c97310f
import  -/  base-4.12.0.0:GHC.Show fa6032f3f820e8e8ec87b97bdca4e160
import  -/  base-4.12.0.0:Prelude 80c668cb99fbafebd524c5e897f8c982
import  -/  containers-0.6.0.1:Data.Map.Strict d8ed60b09294ffcb08c11d3480e21b5e
import  -/  containers-0.6.0.1:Data.Set 119332ba63a6365e1f672e0a39639fe4
import  -/  containers-0.6.0.1:Data.Set.Internal c978fa4af547780822806dfe81b0f44e
import  -/  containers-0.6.0.1:Data.Tree fac5bc2c0cb1c1840f24b65887b8d50e
import  -/  ghc-prim-0.5.3:GHC.Classes 6002495dc43e58d28c87e5e5e058752a
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
fixities infixr 0 -->, infixl 9 .$, infixr 0 .:, infixr 0 .=
f0d52955e004c3f2895d7ad992cc5581
  $fEqInductor :: GHC.Classes.Eq Math.Term.Inductor
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.Inductor
                  Math.Term.$fEqInductor_$c==
                  Math.Term.$fEqInductor_$c/= -}
f0d52955e004c3f2895d7ad992cc5581
  $fEqInductor_$c/= ::
    Math.Term.Inductor -> Math.Term.Inductor -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(SL),1*U(U,1*C1(U))><S(SL),1*U(U,1*C1(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Math.Term.Inductor) (y :: Math.Term.Inductor) ->
                 case Math.Term.$fEqInductor_$c== x y of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
f0d52955e004c3f2895d7ad992cc5581
  $fEqInductor_$c== ::
    Math.Term.Inductor -> Math.Term.Inductor -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(SL),1*U(U,1*C1(U))><S(SL),1*U(U,1*C1(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Math.Term.Inductor) (w1 :: Math.Term.Inductor) ->
                 case w of ww { Math.Term.Inductor ww1 ww2 ->
                 case w1 of ww3 { Math.Term.Inductor ww4 ww5 ->
                 Math.Term.$w$c== ww1 ww2 ww4 ww5 } }) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fEqInductor_$c==1 ::
    Math.Term.Term -> Math.Term.Term -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><S,U> -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fEqPrimConst :: GHC.Classes.Eq Math.Term.PrimConst
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.PrimConst
                  Math.Term.$fEqPrimConst_$c==
                  Math.Term.$fEqPrimConst_$c/= -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fEqPrimConst_$c/= ::
    Math.Term.PrimConst -> Math.Term.PrimConst -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Math.Term.PrimConst) (y :: Math.Term.PrimConst) ->
                 case x of wild2 {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Math.Term.PrimConst
                             wild2 of a# { DEFAULT ->
                      case GHC.Prim.dataToTag# @ Math.Term.PrimConst y of b# { DEFAULT ->
                      case GHC.Prim.==# a# b# of lwild {
                        DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } } }
                   Math.Term.DefConst a1
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True
                        Math.Term.DefConst b1
                        -> case GHC.Base.eqString a1 b1 of wild4 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fEqPrimConst_$c== ::
    Math.Term.PrimConst -> Math.Term.PrimConst -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Math.Term.PrimConst) (ds1 :: Math.Term.PrimConst) ->
                 case ds of wild2 {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Math.Term.PrimConst
                             wild2 of a# { DEFAULT ->
                      case GHC.Prim.dataToTag#
                             @ Math.Term.PrimConst
                             ds1 of b# { DEFAULT ->
                      GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# a# b#) } }
                   Math.Term.DefConst a1
                   -> case ds1 of wild3 {
                        DEFAULT -> GHC.Types.False
                        Math.Term.DefConst b1 -> GHC.Base.eqString a1 b1 } }) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fEqTerm :: GHC.Classes.Eq Math.Term.Term
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.Term
                  Math.Term.$fEqInductor_$c==1
                  Math.Term.$fEqTerm_$c/= -}
cb71c41fabac6a5ef20c9f02bd912331
  $fEqTerm_$c/= :: Math.Term.Term -> Math.Term.Term -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><S,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Math.Term.Term) (y :: Math.Term.Term) ->
                 case Math.Term.$fEqInductor_$c==1 x y of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b44e7245864233b86af4dac9bf2fc883
  $fEqTypeRel :: GHC.Classes.Eq Math.Term.TypeRel
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.TypeRel
                  Math.Term.$fEqTypeRel_$c==
                  Math.Term.$fEqTypeRel_$c/= -}
b44e7245864233b86af4dac9bf2fc883
  $fEqTypeRel_$c/= ::
    Math.Term.TypeRel -> Math.Term.TypeRel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Math.Term.TypeRel) (y :: Math.Term.TypeRel) ->
                 case x of wild2 {
                   Math.Term.EQUIV
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True Math.Term.EQUIV -> GHC.Types.False }
                   Math.Term.SUBTYPE
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True Math.Term.SUBTYPE -> GHC.Types.False }
                   Math.Term.SUPERTYPE
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True Math.Term.SUPERTYPE -> GHC.Types.False }
                   Math.Term.NOTEQ
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True
                        Math.Term.NOTEQ -> GHC.Types.False } }) -}
b44e7245864233b86af4dac9bf2fc883
  $fEqTypeRel_$c== ::
    Math.Term.TypeRel -> Math.Term.TypeRel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Math.Term.TypeRel)
                   (ds1 :: Math.Term.TypeRel) ->
                 case ds of wild2 {
                   Math.Term.EQUIV
                   -> case ds1 of wild3 {
                        DEFAULT -> GHC.Types.False Math.Term.EQUIV -> GHC.Types.True }
                   Math.Term.SUBTYPE
                   -> case ds1 of wild3 {
                        DEFAULT -> GHC.Types.False Math.Term.SUBTYPE -> GHC.Types.True }
                   Math.Term.SUPERTYPE
                   -> case ds1 of wild3 {
                        DEFAULT -> GHC.Types.False Math.Term.SUPERTYPE -> GHC.Types.True }
                   Math.Term.NOTEQ
                   -> case ds1 of wild3 {
                        DEFAULT -> GHC.Types.False
                        Math.Term.NOTEQ -> GHC.Types.True } }) -}
869cdeb95cd6029378befa2ddccb378d
  $fMonoidContext :: GHC.Base.Monoid Math.Term.Context
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.Context
                  Math.Term.$fSemigroupContext
                  Math.Term.ctxEmp
                  Math.Term.$fMonoidContext_$c<>
                  Math.Term.$fMonoidContext_go -}
869cdeb95cd6029378befa2ddccb378d
  $fMonoidContext_$c<> ::
    Math.Term.Context -> Math.Term.Context -> Math.Term.Context
  {- Arity: 2, Strictness: <S,1*U(1*U,1*U)><S,1*U(1*U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ctx10 :: Math.Term.Context) (ctx11 :: Math.Term.Context) ->
                 case ctx10 of wild2 { Math.Term.Ctx ms it1 ->
                 case ctx11 of wild3 { Math.Term.Ctx ns it2 ->
                 Math.Term.Ctx
                   (Math.Term.$fMonoidContext_$sunion ms ns)
                   (Math.Term.$fMonoidContext_$c<>1 it1 it2) } }) -}
96245e8924a8a0a25d6a45f11feba59a
  $fMonoidContext_$c<>1 ::
    Math.Term.InductionTree
    -> Math.Term.InductionTree -> Math.Term.InductionTree
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (ind1 :: Math.Term.InductionTree)
                   (ind2 :: Math.Term.InductionTree) ->
                 Math.Term.$fMonoidContext_go3
                   Math.Term.emptyMT
                   (Data.Set.Internal.$fDataSet_go
                      @ Math.Term.Inductor
                      (GHC.Types.[] @ Math.Term.Inductor)
                      (Math.Term.$fMonoidContext_$sfromList
                         (GHC.Base.++
                            @ Math.Term.Inductor
                            (Math.Term.$fMonoidContext_go1
                               (GHC.Types.[] @ Math.Term.Inductor)
                               ind1)
                            (Math.Term.$fMonoidContext_go1
                               (GHC.Types.[] @ Math.Term.Inductor)
                               ind2))))) -}
ba490a2ab9d6477b92b850f9f004253c
  $fMonoidContext_$sfromList ::
    [Math.Term.Inductor] -> Data.Set.Internal.Set Math.Term.Inductor
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Math.Term.Inductor]) ->
                 case ds of wild2 {
                   [] -> Data.Set.Internal.Tip @ Math.Term.Inductor
                   : x ds1
                   -> case ds1 of wild3 {
                        []
                        -> case x of dt { Math.Term.Inductor ipv ipv1 ->
                           Data.Set.Internal.Bin
                             @ Math.Term.Inductor
                             1#
                             dt
                             (Data.Set.Internal.Tip @ Math.Term.Inductor)
                             (Data.Set.Internal.Tip @ Math.Term.Inductor) }
                        : ipv ipv1
                        -> case x of ww { Math.Term.Inductor ww1 ww2 ->
                           case ipv of ww3 { Math.Term.Inductor ww4 ww5 ->
                           case Math.Term.relation ww1 ww4 of wild4 {
                             Math.Term.EQUIV
                             -> let {
                                  a :: Math.Term.Term = ww2 ww1
                                } in
                                let {
                                  b :: Math.Term.Term = ww5 ww4
                                } in
                                case Math.Term.$fEqInductor_$c==1 a b of wild5 {
                                  GHC.Types.False
                                  -> case Math.Term.$fMonoidContext_goRelation
                                            (Math.Term.alphaReduce a)
                                            (Math.Term.alphaReduce b) of wild6 {
                                       DEFAULT
                                       -> Math.Term.$fMonoidContext_go2
                                            wild3
                                            (Data.Set.Internal.Bin
                                               @ Math.Term.Inductor
                                               1#
                                               ww
                                               (Data.Set.Internal.Tip @ Math.Term.Inductor)
                                               (Data.Set.Internal.Tip @ Math.Term.Inductor))
                                       Math.Term.SUBTYPE
                                       -> Math.Term.$wgo3
                                            1#
                                            (Data.Set.Internal.Bin
                                               @ Math.Term.Inductor
                                               1#
                                               ww
                                               (Data.Set.Internal.Tip @ Math.Term.Inductor)
                                               (Data.Set.Internal.Tip @ Math.Term.Inductor))
                                            wild3 }
                                  GHC.Types.True
                                  -> Math.Term.$fMonoidContext_go2
                                       wild3
                                       (Data.Set.Internal.Bin
                                          @ Math.Term.Inductor
                                          1#
                                          ww
                                          (Data.Set.Internal.Tip @ Math.Term.Inductor)
                                          (Data.Set.Internal.Tip @ Math.Term.Inductor)) }
                             Math.Term.SUBTYPE
                             -> Math.Term.$wgo3
                                  1#
                                  (Data.Set.Internal.Bin
                                     @ Math.Term.Inductor
                                     1#
                                     ww
                                     (Data.Set.Internal.Tip @ Math.Term.Inductor)
                                     (Data.Set.Internal.Tip @ Math.Term.Inductor))
                                  wild3
                             Math.Term.SUPERTYPE
                             -> Math.Term.$fMonoidContext_go2
                                  wild3
                                  (Data.Set.Internal.Bin
                                     @ Math.Term.Inductor
                                     1#
                                     ww
                                     (Data.Set.Internal.Tip @ Math.Term.Inductor)
                                     (Data.Set.Internal.Tip @ Math.Term.Inductor))
                             Math.Term.NOTEQ
                             -> Math.Term.$fMonoidContext_go2
                                  wild3
                                  (Data.Set.Internal.Bin
                                     @ Math.Term.Inductor
                                     1#
                                     ww
                                     (Data.Set.Internal.Tip @ Math.Term.Inductor)
                                     (Data.Set.Internal.Tip @ Math.Term.Inductor)) } } } } }) -}
536545389dcf7d2ac7875a54b5b6569b
  $fMonoidContext_$sunion ::
    Data.Set.Internal.Set Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
869cdeb95cd6029378befa2ddccb378d
  $fMonoidContext_go :: [Math.Term.Context] -> Math.Term.Context
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [Math.Term.Context]) ->
                 case Math.Term.$wgo w of ww { (#,#) ww1 ww2 ->
                 Math.Term.Ctx ww1 ww2 }) -}
96245e8924a8a0a25d6a45f11feba59a
  $fMonoidContext_go1 ::
    [Math.Term.Inductor]
    -> Math.Term.InductionTree -> [Math.Term.Inductor]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,1*U> -}
f03d492b6613a9115d83597bb96f1d57
  $fMonoidContext_go2 ::
    [Math.Term.Inductor]
    -> Data.Set.Internal.Set Math.Term.Inductor
    -> Data.Set.Internal.Set Math.Term.Inductor
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
96245e8924a8a0a25d6a45f11feba59a
  $fMonoidContext_go3 ::
    Math.Term.InductionTree
    -> [Math.Term.Inductor] -> Math.Term.InductionTree
  {- Arity: 2, Strictness: <S,U><S,1*U> -}
cb71c41fabac6a5ef20c9f02bd912331
  $fMonoidContext_goRelation ::
    Math.Term.Term -> Math.Term.Term -> Math.Term.TypeRel
  {- Arity: 2, Strictness: <S,U><S,U> -}
cb71c41fabac6a5ef20c9f02bd912331
  $fMonoidTerm :: GHC.Base.Monoid Math.Term.Term
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.Term
                  Math.Term.$fSemigroupTerm
                  Math.Term.U
                  Math.Term.$fMonoidTerm_$c<>
                  Math.Term.$fMonoidTerm_go -}
cb71c41fabac6a5ef20c9f02bd912331
  $fMonoidTerm1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Pair) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fMonoidTerm_$c<> ::
    Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (y :: Math.Term.Term) ->
                 Math.Term.Ap (Math.Term.Ap Math.Term.$fMonoidTerm1 x) y) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fMonoidTerm_go :: [Math.Term.Term] -> Math.Term.Term
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f0d52955e004c3f2895d7ad992cc5581
  $fOrdInductor :: GHC.Classes.Ord Math.Term.Inductor
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.Inductor
                  Math.Term.$fEqInductor
                  Math.Term.$fOrdInductor_$ccompare
                  Math.Term.$fOrdInductor_$c<
                  Math.Term.$fOrdInductor_$c<=
                  Math.Term.$fOrdInductor_$c>
                  Math.Term.$fOrdInductor_$c>=
                  Math.Term.$fOrdInductor_$cmax
                  Math.Term.$fOrdInductor_$cmin -}
f0d52955e004c3f2895d7ad992cc5581
  $fOrdInductor_$c< ::
    Math.Term.Inductor -> Math.Term.Inductor -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(SL),1*U(U,1*C1(U))><S(SL),1*U(U,1*C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Inductor) (y :: Math.Term.Inductor) ->
                 case Math.Term.$fOrdInductor_$ccompare x y of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
f0d52955e004c3f2895d7ad992cc5581
  $fOrdInductor_$c<= ::
    Math.Term.Inductor -> Math.Term.Inductor -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(SL),1*U(U,1*C1(U))><S(SL),1*U(U,1*C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Inductor) (y :: Math.Term.Inductor) ->
                 case Math.Term.$fOrdInductor_$ccompare x y of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
f0d52955e004c3f2895d7ad992cc5581
  $fOrdInductor_$c> ::
    Math.Term.Inductor -> Math.Term.Inductor -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(SL),1*U(U,1*C1(U))><S(SL),1*U(U,1*C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Inductor) (y :: Math.Term.Inductor) ->
                 case Math.Term.$fOrdInductor_$ccompare x y of wild2 {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
f0d52955e004c3f2895d7ad992cc5581
  $fOrdInductor_$c>= ::
    Math.Term.Inductor -> Math.Term.Inductor -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <S(SL),1*U(U,1*C1(U))><S(SL),1*U(U,1*C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Inductor) (y :: Math.Term.Inductor) ->
                 case Math.Term.$fOrdInductor_$ccompare x y of wild2 {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
f0d52955e004c3f2895d7ad992cc5581
  $fOrdInductor_$ccompare ::
    Math.Term.Inductor -> Math.Term.Inductor -> GHC.Types.Ordering
  {- Arity: 2,
     Strictness: <S(SL),1*U(U,1*C1(U))><S(SL),1*U(U,1*C1(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Math.Term.Inductor) (w1 :: Math.Term.Inductor) ->
                 case w of ww { Math.Term.Inductor ww1 ww2 ->
                 case w1 of ww3 { Math.Term.Inductor ww4 ww5 ->
                 Math.Term.$w$ccompare ww1 ww2 ww4 ww5 } }) -}
f0d52955e004c3f2895d7ad992cc5581
  $fOrdInductor_$cmax ::
    Math.Term.Inductor -> Math.Term.Inductor -> Math.Term.Inductor
  {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S(SL),1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Inductor) (y :: Math.Term.Inductor) ->
                 case Math.Term.$fOrdInductor_$ccompare x y of wild2 {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
f0d52955e004c3f2895d7ad992cc5581
  $fOrdInductor_$cmin ::
    Math.Term.Inductor -> Math.Term.Inductor -> Math.Term.Inductor
  {- Arity: 2, Strictness: <S(SL),1*U(U,U)><S(SL),1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Inductor) (y :: Math.Term.Inductor) ->
                 case Math.Term.$fOrdInductor_$ccompare x y of wild2 {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fOrdPrimConst :: GHC.Classes.Ord Math.Term.PrimConst
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.PrimConst
                  Math.Term.$fEqPrimConst
                  Math.Term.$fOrdPrimConst_$ccompare
                  Math.Term.$fOrdPrimConst_$c<
                  Math.Term.$fOrdPrimConst_$c<=
                  Math.Term.$fOrdPrimConst_$c>
                  Math.Term.$fOrdPrimConst_$c>=
                  Math.Term.$fOrdPrimConst_$cmax
                  Math.Term.$fOrdPrimConst_$cmin -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fOrdPrimConst_$c< ::
    Math.Term.PrimConst -> Math.Term.PrimConst -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (x :: Math.Term.PrimConst)
                   (y :: Math.Term.PrimConst) ->
                 case x of wild2 {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Math.Term.PrimConst
                             wild2 of a# { DEFAULT ->
                      case GHC.Prim.dataToTag# @ Math.Term.PrimConst y of b# { DEFAULT ->
                      case GHC.Prim.<# a# b# of lwild {
                        DEFAULT -> GHC.Types.False 1# -> GHC.Types.True } } }
                   Math.Term.DefConst a1
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True
                        Math.Term.DefConst b1
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild4 {
                             DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True } } }) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fOrdPrimConst_$c<= ::
    Math.Term.PrimConst -> Math.Term.PrimConst -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (x :: Math.Term.PrimConst)
                   (y :: Math.Term.PrimConst) ->
                 case x of wild2 {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Math.Term.PrimConst
                             wild2 of a# { DEFAULT ->
                      case GHC.Prim.dataToTag# @ Math.Term.PrimConst y of b# { DEFAULT ->
                      case GHC.Prim.<# a# b# of lwild {
                        DEFAULT
                        -> case GHC.Prim.==# a# b# of lwild1 {
                             DEFAULT -> GHC.Types.False 1# -> GHC.Types.True }
                        1# -> GHC.Types.True } } }
                   Math.Term.DefConst a1
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True
                        Math.Term.DefConst b1
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild4 {
                             DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False } } }) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fOrdPrimConst_$c> ::
    Math.Term.PrimConst -> Math.Term.PrimConst -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (x :: Math.Term.PrimConst)
                   (y :: Math.Term.PrimConst) ->
                 case x of wild2 {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Math.Term.PrimConst
                             wild2 of a# { DEFAULT ->
                      case GHC.Prim.dataToTag# @ Math.Term.PrimConst y of b# { DEFAULT ->
                      case GHC.Prim.<# a# b# of lwild {
                        DEFAULT
                        -> case GHC.Prim.==# a# b# of lwild1 {
                             DEFAULT -> GHC.Types.True 1# -> GHC.Types.False }
                        1# -> GHC.Types.False } } }
                   Math.Term.DefConst a1
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.False
                        Math.Term.DefConst b1
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild4 {
                             DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True } } }) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fOrdPrimConst_$c>= ::
    Math.Term.PrimConst -> Math.Term.PrimConst -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (x :: Math.Term.PrimConst)
                   (y :: Math.Term.PrimConst) ->
                 case x of wild2 {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Math.Term.PrimConst
                             wild2 of a# { DEFAULT ->
                      case GHC.Prim.dataToTag# @ Math.Term.PrimConst y of b# { DEFAULT ->
                      case GHC.Prim.<# a# b# of lwild {
                        DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } } }
                   Math.Term.DefConst a1
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.False
                        Math.Term.DefConst b1
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild4 {
                             DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } }) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fOrdPrimConst_$ccompare ::
    Math.Term.PrimConst -> Math.Term.PrimConst -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (a :: Math.Term.PrimConst)
                   (b :: Math.Term.PrimConst) ->
                 case a of wild2 {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Math.Term.PrimConst
                             wild2 of a# { DEFAULT ->
                      case GHC.Prim.dataToTag# @ Math.Term.PrimConst b of b# { DEFAULT ->
                      case GHC.Prim.<# a# b# of lwild {
                        DEFAULT
                        -> case GHC.Prim.==# a# b# of lwild1 {
                             DEFAULT -> GHC.Types.GT 1# -> GHC.Types.EQ }
                        1# -> GHC.Types.LT } } }
                   Math.Term.DefConst a1
                   -> case b of wild3 {
                        DEFAULT -> GHC.Types.LT
                        Math.Term.DefConst b1
                        -> GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 } }) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fOrdPrimConst_$cmax ::
    Math.Term.PrimConst -> Math.Term.PrimConst -> Math.Term.PrimConst
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (x :: Math.Term.PrimConst)
                   (y :: Math.Term.PrimConst) ->
                 case x of wild2 {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Math.Term.PrimConst
                             wild2 of a# { DEFAULT ->
                      case GHC.Prim.dataToTag# @ Math.Term.PrimConst y of b# { DEFAULT ->
                      case GHC.Prim.<# a# b# of lwild {
                        DEFAULT
                        -> case GHC.Prim.==# a# b# of lwild1 { DEFAULT -> wild2 1# -> y }
                        1# -> y } } }
                   Math.Term.DefConst a1
                   -> case y of wild3 {
                        DEFAULT -> wild3
                        Math.Term.DefConst b1
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild4 {
                             DEFAULT -> wild3 GHC.Types.GT -> wild2 } } }) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fOrdPrimConst_$cmin ::
    Math.Term.PrimConst -> Math.Term.PrimConst -> Math.Term.PrimConst
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (x :: Math.Term.PrimConst)
                   (y :: Math.Term.PrimConst) ->
                 case x of wild2 {
                   DEFAULT
                   -> case GHC.Prim.dataToTag#
                             @ Math.Term.PrimConst
                             wild2 of a# { DEFAULT ->
                      case GHC.Prim.dataToTag# @ Math.Term.PrimConst y of b# { DEFAULT ->
                      case GHC.Prim.<# a# b# of lwild {
                        DEFAULT
                        -> case GHC.Prim.==# a# b# of lwild1 { DEFAULT -> y 1# -> wild2 }
                        1# -> wild2 } } }
                   Math.Term.DefConst a1
                   -> case y of wild3 {
                        DEFAULT -> wild2
                        Math.Term.DefConst b1
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild4 {
                             DEFAULT -> wild2 GHC.Types.GT -> wild3 } } }) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fOrdTerm :: GHC.Classes.Ord Math.Term.Term
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.Term
                  Math.Term.$fEqTerm
                  Math.Term.$fOrdTerm_$ccompare
                  Math.Term.$fOrdTerm_$c<
                  Math.Term.$fOrdTerm_$c<=
                  Math.Term.$fOrdTerm_$c>
                  Math.Term.$fOrdTerm_$c>=
                  Math.Term.$fOrdTerm_$cmax
                  Math.Term.$fOrdTerm_$cmin -}
cb71c41fabac6a5ef20c9f02bd912331
  $fOrdTerm_$c< :: Math.Term.Term -> Math.Term.Term -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (y :: Math.Term.Term) ->
                 case Math.Term.relation x y of wild2 {
                   DEFAULT -> GHC.Types.False
                   Math.Term.SUBTYPE -> GHC.Types.True }) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fOrdTerm_$c<= ::
    Math.Term.Term -> Math.Term.Term -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (y :: Math.Term.Term) ->
                 case Math.Term.relation x y of wild2 {
                   DEFAULT -> GHC.Types.True
                   Math.Term.SUPERTYPE -> GHC.Types.False
                   Math.Term.NOTEQ -> GHC.Types.False }) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fOrdTerm_$c> :: Math.Term.Term -> Math.Term.Term -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (y :: Math.Term.Term) ->
                 case Math.Term.relation x y of wild2 {
                   DEFAULT -> GHC.Types.False
                   Math.Term.SUPERTYPE -> GHC.Types.True
                   Math.Term.NOTEQ -> GHC.Types.True }) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fOrdTerm_$c>= ::
    Math.Term.Term -> Math.Term.Term -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (y :: Math.Term.Term) ->
                 case Math.Term.relation x y of wild2 {
                   DEFAULT -> GHC.Types.True
                   Math.Term.SUBTYPE -> GHC.Types.False }) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fOrdTerm_$ccompare ::
    Math.Term.Term -> Math.Term.Term -> GHC.Types.Ordering
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (x :: Math.Term.Term) (y :: Math.Term.Term) ->
                 case Math.Term.relation x y of wild2 {
                   Math.Term.EQUIV -> GHC.Types.EQ
                   Math.Term.SUBTYPE -> GHC.Types.LT
                   Math.Term.SUPERTYPE -> GHC.Types.GT
                   Math.Term.NOTEQ -> GHC.Types.GT }) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fOrdTerm_$cmax ::
    Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (y :: Math.Term.Term) ->
                 case Math.Term.relation x y of wild2 {
                   DEFAULT -> y Math.Term.SUPERTYPE -> x Math.Term.NOTEQ -> x }) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fOrdTerm_$cmin ::
    Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (y :: Math.Term.Term) ->
                 case Math.Term.relation x y of wild2 {
                   DEFAULT -> x Math.Term.SUPERTYPE -> y Math.Term.NOTEQ -> y }) -}
b44e7245864233b86af4dac9bf2fc883
  $fOrdTypeRel :: GHC.Classes.Ord Math.Term.TypeRel
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.TypeRel
                  Math.Term.$fEqTypeRel
                  Math.Term.$fOrdTypeRel_$ccompare
                  Math.Term.$fOrdTypeRel_$c<
                  Math.Term.$fOrdTypeRel_$c<=
                  Math.Term.$fOrdTypeRel_$c>
                  Math.Term.$fOrdTypeRel_$c>=
                  Math.Term.$fOrdTypeRel_$cmax
                  Math.Term.$fOrdTypeRel_$cmin -}
b44e7245864233b86af4dac9bf2fc883
  $fOrdTypeRel_$c< ::
    Math.Term.TypeRel -> Math.Term.TypeRel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Math.Term.TypeRel) (y :: Math.Term.TypeRel) ->
                 case x of wild2 {
                   Math.Term.EQUIV
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.False
                        Math.Term.SUPERTYPE -> GHC.Types.True
                        Math.Term.NOTEQ -> GHC.Types.True }
                   Math.Term.SUBTYPE
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True Math.Term.SUBTYPE -> GHC.Types.False }
                   Math.Term.SUPERTYPE
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.False Math.Term.NOTEQ -> GHC.Types.True }
                   Math.Term.NOTEQ
                   -> case y of wild3 { DEFAULT -> GHC.Types.False } }) -}
b44e7245864233b86af4dac9bf2fc883
  $fOrdTypeRel_$c<= ::
    Math.Term.TypeRel -> Math.Term.TypeRel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Math.Term.TypeRel) (y :: Math.Term.TypeRel) ->
                 case x of wild2 {
                   Math.Term.EQUIV
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True Math.Term.SUBTYPE -> GHC.Types.False }
                   Math.Term.SUBTYPE -> case y of wild3 { DEFAULT -> GHC.Types.True }
                   Math.Term.SUPERTYPE
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.False
                        Math.Term.SUPERTYPE -> GHC.Types.True
                        Math.Term.NOTEQ -> GHC.Types.True }
                   Math.Term.NOTEQ
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.False
                        Math.Term.NOTEQ -> GHC.Types.True } }) -}
b44e7245864233b86af4dac9bf2fc883
  $fOrdTypeRel_$c> ::
    Math.Term.TypeRel -> Math.Term.TypeRel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Math.Term.TypeRel) (y :: Math.Term.TypeRel) ->
                 case x of wild2 {
                   Math.Term.EQUIV
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.False Math.Term.SUBTYPE -> GHC.Types.True }
                   Math.Term.SUBTYPE -> case y of wild3 { DEFAULT -> GHC.Types.False }
                   Math.Term.SUPERTYPE
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True
                        Math.Term.SUPERTYPE -> GHC.Types.False
                        Math.Term.NOTEQ -> GHC.Types.False }
                   Math.Term.NOTEQ
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True
                        Math.Term.NOTEQ -> GHC.Types.False } }) -}
b44e7245864233b86af4dac9bf2fc883
  $fOrdTypeRel_$c>= ::
    Math.Term.TypeRel -> Math.Term.TypeRel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Math.Term.TypeRel) (y :: Math.Term.TypeRel) ->
                 case x of wild2 {
                   Math.Term.EQUIV
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True
                        Math.Term.SUPERTYPE -> GHC.Types.False
                        Math.Term.NOTEQ -> GHC.Types.False }
                   Math.Term.SUBTYPE
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.False Math.Term.SUBTYPE -> GHC.Types.True }
                   Math.Term.SUPERTYPE
                   -> case y of wild3 {
                        DEFAULT -> GHC.Types.True Math.Term.NOTEQ -> GHC.Types.False }
                   Math.Term.NOTEQ
                   -> case y of wild3 { DEFAULT -> GHC.Types.True } }) -}
b44e7245864233b86af4dac9bf2fc883
  $fOrdTypeRel_$ccompare ::
    Math.Term.TypeRel -> Math.Term.TypeRel -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Math.Term.TypeRel)
                   (ds1 :: Math.Term.TypeRel) ->
                 case ds of wild2 {
                   Math.Term.EQUIV
                   -> case ds1 of wild3 {
                        Math.Term.EQUIV -> GHC.Types.EQ
                        Math.Term.SUBTYPE -> GHC.Types.GT
                        Math.Term.SUPERTYPE -> GHC.Types.LT
                        Math.Term.NOTEQ -> GHC.Types.LT }
                   Math.Term.SUBTYPE
                   -> case ds1 of wild3 {
                        DEFAULT -> GHC.Types.LT Math.Term.SUBTYPE -> GHC.Types.EQ }
                   Math.Term.SUPERTYPE
                   -> case ds1 of wild3 {
                        DEFAULT -> GHC.Types.GT
                        Math.Term.SUPERTYPE -> GHC.Types.EQ
                        Math.Term.NOTEQ -> GHC.Types.LT }
                   Math.Term.NOTEQ
                   -> case ds1 of wild3 {
                        DEFAULT -> GHC.Types.GT Math.Term.NOTEQ -> GHC.Types.EQ } }) -}
b44e7245864233b86af4dac9bf2fc883
  $fOrdTypeRel_$cmax ::
    Math.Term.TypeRel -> Math.Term.TypeRel -> Math.Term.TypeRel
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.TypeRel) (y :: Math.Term.TypeRel) ->
                 case x of wild2 {
                   Math.Term.EQUIV
                   -> case y of wild3 {
                        DEFAULT -> wild3 Math.Term.SUBTYPE -> Math.Term.EQUIV }
                   Math.Term.SUBTYPE -> y
                   Math.Term.SUPERTYPE
                   -> case y of wild3 {
                        DEFAULT -> Math.Term.SUPERTYPE Math.Term.NOTEQ -> Math.Term.NOTEQ }
                   Math.Term.NOTEQ
                   -> case y of wild3 { DEFAULT -> Math.Term.NOTEQ } }) -}
b44e7245864233b86af4dac9bf2fc883
  $fOrdTypeRel_$cmin ::
    Math.Term.TypeRel -> Math.Term.TypeRel -> Math.Term.TypeRel
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Math.Term.TypeRel) (y :: Math.Term.TypeRel) ->
                 case x of wild2 {
                   Math.Term.EQUIV
                   -> case y of wild3 {
                        DEFAULT -> Math.Term.EQUIV Math.Term.SUBTYPE -> Math.Term.SUBTYPE }
                   Math.Term.SUBTYPE
                   -> case y of wild3 { DEFAULT -> Math.Term.SUBTYPE }
                   Math.Term.SUPERTYPE
                   -> case y of wild3 {
                        DEFAULT -> wild3
                        Math.Term.SUPERTYPE -> Math.Term.SUPERTYPE
                        Math.Term.NOTEQ -> Math.Term.SUPERTYPE }
                   Math.Term.NOTEQ -> y }) -}
869cdeb95cd6029378befa2ddccb378d
  $fSemigroupContext :: GHC.Base.Semigroup Math.Term.Context
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.Context
                  Math.Term.$fMonoidContext_$c<>
                  Math.Term.$fSemigroupContext_$csconcat
                  Math.Term.$fSemigroupContext_$cstimes -}
869cdeb95cd6029378befa2ddccb378d
  $fSemigroupContext_$csconcat ::
    GHC.Base.NonEmpty Math.Term.Context -> Math.Term.Context
  {- Arity: 1, Strictness: <S(SS),1*U(1*U(U,U),1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.NonEmpty Math.Term.Context) ->
                 case ds of wild2 { GHC.Base.:| a1 as ->
                 Math.Term.$fSemigroupContext_go a1 as }) -}
869cdeb95cd6029378befa2ddccb378d
  $fSemigroupContext_$cstimes ::
    GHC.Real.Integral b => b -> Math.Term.Context -> Math.Term.Context
  {- Arity: 1, Strictness: <L,U> -}
869cdeb95cd6029378befa2ddccb378d
  $fSemigroupContext_go ::
    Math.Term.Context -> [Math.Term.Context] -> Math.Term.Context
  {- Arity: 2, Strictness: <S,1*U(U,U)><S,1*U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Math.Term.Context) (w1 :: [Math.Term.Context]) ->
                 case w of ww { Math.Term.Ctx ww1 ww2 ->
                 case Math.Term.$wgo1 ww1 ww2 w1 of ww3 { (#,#) ww4 ww5 ->
                 Math.Term.Ctx ww4 ww5 } }) -}
96245e8924a8a0a25d6a45f11feba59a
  $fSemigroupInductionTree ::
    GHC.Base.Semigroup Math.Term.InductionTree
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.InductionTree
                  Math.Term.$fMonoidContext_$c<>1
                  Math.Term.$fSemigroupInductionTree_$csconcat
                  Math.Term.$fSemigroupInductionTree_$cstimes -}
96245e8924a8a0a25d6a45f11feba59a
  $fSemigroupInductionTree_$csconcat ::
    GHC.Base.NonEmpty Math.Term.InductionTree
    -> Math.Term.InductionTree
  {- Arity: 1, Strictness: <S(SS),1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.NonEmpty Math.Term.InductionTree) ->
                 case ds of wild2 { GHC.Base.:| a1 as ->
                 Math.Term.$fSemigroupInductionTree_go a1 as }) -}
96245e8924a8a0a25d6a45f11feba59a
  $fSemigroupInductionTree_$cstimes ::
    GHC.Real.Integral b =>
    b -> Math.Term.InductionTree -> Math.Term.InductionTree
  {- Arity: 1, Strictness: <L,U> -}
96245e8924a8a0a25d6a45f11feba59a
  $fSemigroupInductionTree_go ::
    Math.Term.InductionTree
    -> [Math.Term.InductionTree] -> Math.Term.InductionTree
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
cb71c41fabac6a5ef20c9f02bd912331
  $fSemigroupTerm :: GHC.Base.Semigroup Math.Term.Term
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.Term
                  Math.Term.$fMonoidTerm_$c<>
                  Math.Term.$fSemigroupTerm_$csconcat
                  Math.Term.$fSemigroupTerm_$cstimes -}
cb71c41fabac6a5ef20c9f02bd912331
  $fSemigroupTerm_$csconcat ::
    GHC.Base.NonEmpty Math.Term.Term -> Math.Term.Term
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Base.NonEmpty Math.Term.Term) ->
                 case ds of wild2 { GHC.Base.:| a1 as ->
                 Math.Term.$fSemigroupTerm_go a1 as }) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fSemigroupTerm_$cstimes ::
    GHC.Real.Integral b => b -> Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <L,U> -}
cb71c41fabac6a5ef20c9f02bd912331
  $fSemigroupTerm_go ::
    Math.Term.Term -> [Math.Term.Term] -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
869cdeb95cd6029378befa2ddccb378d
  $fShowContext :: GHC.Show.Show Math.Term.Context
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.Context
                  Math.Term.$fShowContext_$cshowsPrec
                  Math.Term.$fShowContext_$cshow
                  Math.Term.$fShowContext_$cshowList -}
869cdeb95cd6029378befa2ddccb378d
  $fShowContext1 ::
    Math.Term.Context -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U(1*U,1*U)><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Context) (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Math.Term.$fShowContext_$cshow x))
                   s) -}
414a7a8124f1df178771b898b2af3925
  $fShowContext2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("given types: \n"#) -}
b37245c26fb2008319bacaa3a98facdb
  $fShowContext3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("context: \n"#) -}
869cdeb95cd6029378befa2ddccb378d
  $fShowContext_$cshow :: Math.Term.Context -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Context) ->
                 case w of ww { Math.Term.Ctx ww1 ww2 ->
                 Math.Term.$w$cshow ww1 ww2 }) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fShowContext_$cshow1 :: Math.Term.Term -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
869cdeb95cd6029378befa2ddccb378d
  $fShowContext_$cshowList :: [Math.Term.Context] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Math.Term.Context]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Math.Term.Context
                   Math.Term.$fShowContext1
                   ls
                   s) -}
869cdeb95cd6029378befa2ddccb378d
  $fShowContext_$cshowsPrec ::
    GHC.Types.Int -> Math.Term.Context -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U(1*U,1*U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Math.Term.Context)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Math.Term.$fShowContext_$cshow x))
                   s) -}
96245e8924a8a0a25d6a45f11feba59a
  $fShowContext_go ::
    Math.Term.InductionTree -> Data.Tree.Forest Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U> -}
13047f82171d184511a2cc2733bf4eac
  $fShowContext_go3 ::
    [Math.Term.Inductor]
    -> Data.Set.Internal.Set Math.Term.Term -> [Math.Term.Inductor]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
96245e8924a8a0a25d6a45f11feba59a
  $fShowInductionTree :: GHC.Show.Show Math.Term.InductionTree
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.InductionTree
                  Math.Term.$fShowInductionTree_$cshowsPrec
                  Math.Term.$fShowInductionTree_$cshow
                  Math.Term.$fShowInductionTree_$cshowList -}
96245e8924a8a0a25d6a45f11feba59a
  $fShowInductionTree_$cshow ::
    Math.Term.InductionTree -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tree :: Math.Term.InductionTree) ->
                 case GHC.List.$w!!
                        @ (Data.Tree.Tree Math.Term.Term)
                        (Math.Term.$fShowContext_go tree)
                        0# of ww { Data.Tree.Node ww1 ww2 ->
                 case Data.Tree.$wfmapTree
                        @ Math.Term.Term
                        @ GHC.Base.String
                        Math.Term.$fShowContext_$cshow1
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 Data.Tree.$wdrawTree ww4 ww5 } }) -}
96245e8924a8a0a25d6a45f11feba59a
  $fShowInductionTree_$cshowList ::
    [Math.Term.InductionTree] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Math.Term.InductionTree]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Math.Term.InductionTree
                   Math.Term.$w$cshowsPrec
                   ls
                   s) -}
96245e8924a8a0a25d6a45f11feba59a
  $fShowInductionTree_$cshowsPrec ::
    GHC.Types.Int -> Math.Term.InductionTree -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Math.Term.InductionTree)
                   (w2 :: GHC.Base.String) ->
                 Math.Term.$w$cshowsPrec w1 w2) -}
f0d52955e004c3f2895d7ad992cc5581
  $fShowInductor :: GHC.Show.Show Math.Term.Inductor
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.Inductor
                  Math.Term.$fShowInductor_$cshowsPrec
                  Math.Term.$fShowInductor_$cshow
                  Math.Term.$fShowInductor_$cshowList -}
f0d52955e004c3f2895d7ad992cc5581
  $fShowInductor1 ::
    Math.Term.Inductor -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S(SL),1*U(U,1*C1(U))><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Math.Term.Inductor) (w1 :: GHC.Base.String) ->
                 case w of ww { Math.Term.Inductor ww1 ww2 ->
                 Math.Term.$w$cshowsPrec1 ww1 ww2 w1 }) -}
a049a2e6a350691815729eebcd9051d9
  $fShowInductor2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   Math.Term.$fShowInductor3) -}
a69f7634bf70ef7d660df66a331f2151
  $fShowInductor3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" \\226\\137\\131 "#) -}
f0d52955e004c3f2895d7ad992cc5581
  $fShowInductor_$cshow :: Math.Term.Inductor -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SL),1*U(U,1*C1(U))>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Inductor) ->
                 case w of ww { Math.Term.Inductor ww1 ww2 ->
                 Math.Term.$w$cshow1 ww1 ww2 }) -}
f0d52955e004c3f2895d7ad992cc5581
  $fShowInductor_$cshowList :: [Math.Term.Inductor] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Math.Term.Inductor]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Math.Term.Inductor
                   Math.Term.$fShowInductor1
                   ls
                   s) -}
f0d52955e004c3f2895d7ad992cc5581
  $fShowInductor_$cshowsPrec ::
    GHC.Types.Int -> Math.Term.Inductor -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S(SL),1*U(U,1*C1(U))><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Math.Term.Inductor)
                   (w2 :: GHC.Base.String) ->
                 case w1 of ww { Math.Term.Inductor ww1 ww2 ->
                 Math.Term.$w$cshowsPrec1 ww1 ww2 w2 }) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fShowPrimConst :: GHC.Show.Show Math.Term.PrimConst
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.PrimConst
                  Math.Term.$fShowPrimConst_$cshowsPrec
                  Math.Term.$fShowPrimConst_$cshow
                  Math.Term.$fShowPrimConst_$cshowList -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fShowPrimConst1 ::
    Math.Term.PrimConst -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.PrimConst) (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Math.Term.$fShowPrimConst_$cshow x))
                   s) -}
5433b05f1c34dfa32f11a8b40d2cfcb3
  $fShowPrimConst10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   Math.Term.$fShowPrimConst11) -}
8ea569698c671dd5f8143d17bd76fdbd
  $fShowPrimConst11 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\137\\161"#) -}
91a43c7150962dc393182dabe690661e
  $fShowPrimConst12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowPrimConst13) -}
f6d4fc81d76ebfc48262265ddbdb303c
  $fShowPrimConst13 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":"#) -}
c204ef9115092a417e7448b9cb0fcfda
  $fShowPrimConst14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowPrimConst15) -}
714bd9e38be8fa87f7b5d8f2d43af22a
  $fShowPrimConst15 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("prjr"#) -}
9a811f51eeedfafaf1ec9d68eb3f7e4d
  $fShowPrimConst16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowPrimConst17) -}
b6b4bfc414312c3b1fa8d6226a2b72eb
  $fShowPrimConst17 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("prjl"#) -}
3eb084acf9e208d47890b9f75413c61f
  $fShowPrimConst18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowPrimConst19) -}
5615a733eb611fbd9c54e51492c73121
  $fShowPrimConst19 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("inr"#) -}
000aafbebb0b5b2ed6a631d6f4b834cf
  $fShowPrimConst2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   Math.Term.$fShowPrimConst3) -}
141c9a2c38eeb417bc72db784a658c73
  $fShowPrimConst20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowPrimConst21) -}
06adbf755531c1a72fb6b67a0eeeac6c
  $fShowPrimConst21 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("inl"#) -}
673df3a844b5b4c204e84766aee05892
  $fShowPrimConst22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowPrimConst23) -}
778b64e327eda8898bfe56cb826f21c0
  $fShowPrimConst23 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("+"#) -}
4806b24642e69a2cc84301161b4f5300
  $fShowPrimConst24 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   Math.Term.$fShowPrimConst25) -}
f8f8d0a861a73c6cd51c1f987147333d
  $fShowPrimConst25 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\195\\151"#) -}
0b10678dfa61b79b1ab50943190ca1b1
  $fShowPrimConst26 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   Math.Term.$fShowPrimConst27) -}
c5856fa53ac8e11ba51ffbdaf80023e4
  $fShowPrimConst27 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\136\\145"#) -}
c4cc829d3e061ff8ab5973a2e592946d
  $fShowPrimConst28 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   Math.Term.$fShowPrimConst29) -}
d467e10f9db14bad6b824568bace19e5
  $fShowPrimConst29 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\136\\143"#) -}
336483318b9c5b6d25465e9d3c4a5280
  $fShowPrimConst3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\240\\157\\144\\141"#) -}
44b8c499ab7f37907451821f4548dcda
  $fShowPrimConst30 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   Math.Term.$fShowPrimConst31) -}
44473b59e5444dc102345bdef8107594
  $fShowPrimConst31 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\240\\157\\159\\144"#) -}
02adcdc49f16a7269b16cc5896d7ed78
  $fShowPrimConst32 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   Math.Term.$fShowPrimConst33) -}
82abc5f592e8112f0af33c55ce7215e4
  $fShowPrimConst33 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\240\\157\\159\\143"#) -}
ef671fa6e0c49ef5981682e94d99ec36
  $fShowPrimConst34 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   Math.Term.$fShowPrimConst35) -}
3174eb5518ed487d1c8a982bf4e7afaf
  $fShowPrimConst35 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\240\\157\\159\\142"#) -}
eaa9ef179b658059ae82a1421b075a0c
  $fShowPrimConst4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowPrimConst5) -}
07c211a4ede3d68b844759e679377d6b
  $fShowPrimConst5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("="#) -}
9efb69dd21b1cf1ad28eb4c25fcf51fb
  $fShowPrimConst6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowPrimConst7) -}
40d70a4af3e83bb9f3a4007c2ea77b7b
  $fShowPrimConst7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("refl"#) -}
ae0d4a718931cb760e3d84fe32d5b5c3
  $fShowPrimConst8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowPrimConst9) -}
6798c9dac6f38ac29ac8931dc7a86951
  $fShowPrimConst9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("->"#) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fShowPrimConst_$cshow :: Math.Term.PrimConst -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Math.Term.PrimConst) ->
                 case ds of wild2 {
                   Math.Term.DefConst s -> s
                   Math.Term.Zero -> Math.Term.$fShowPrimConst34
                   Math.Term.One -> Math.Term.$fShowPrimConst32
                   Math.Term.Two -> Math.Term.$fShowPrimConst30
                   Math.Term.Pi -> Math.Term.$fShowPrimConst28
                   Math.Term.Sigma -> Math.Term.$fShowPrimConst26
                   Math.Term.Pair -> Math.Term.$fShowPrimConst24
                   Math.Term.Coprod -> Math.Term.$fShowPrimConst22
                   Math.Term.Inl -> Math.Term.$fShowPrimConst20
                   Math.Term.Inr -> Math.Term.$fShowPrimConst18
                   Math.Term.Prjl -> Math.Term.$fShowPrimConst16
                   Math.Term.Prjr -> Math.Term.$fShowPrimConst14
                   Math.Term.DefType -> Math.Term.$fShowPrimConst12
                   Math.Term.DefEq -> Math.Term.$fShowPrimConst10
                   Math.Term.Func -> Math.Term.$fShowPrimConst8
                   Math.Term.Refl -> Math.Term.$fShowPrimConst6
                   Math.Term.Ident -> Math.Term.$fShowPrimConst4
                   Math.Term.Nat -> Math.Term.$fShowPrimConst2 }) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fShowPrimConst_$cshowList ::
    [Math.Term.PrimConst] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Math.Term.PrimConst]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Math.Term.PrimConst
                   Math.Term.$fShowPrimConst1
                   ls
                   s) -}
8b99933ee4d6b7dc1ae244851d0cd05f
  $fShowPrimConst_$cshowsPrec ::
    GHC.Types.Int -> Math.Term.PrimConst -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Math.Term.PrimConst)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Math.Term.$fShowPrimConst_$cshow x))
                   s) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fShowTerm :: GHC.Show.Show Math.Term.Term
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.Term
                  Math.Term.$fShowTerm_$cshowsPrec
                  Math.Term.$fShowContext_$cshow1
                  Math.Term.$fShowTerm_$cshowList -}
cb71c41fabac6a5ef20c9f02bd912331
  $fShowTerm1 ::
    Math.Term.Term -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (s :: GHC.Base.String)[OneShot] ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Math.Term.$fShowContext_$cshow1 x))
                   s) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fShowTerm_$cshowList :: [Math.Term.Term] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Math.Term.Term]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Math.Term.Term Math.Term.$fShowTerm1 ls s) -}
cb71c41fabac6a5ef20c9f02bd912331
  $fShowTerm_$cshowsPrec ::
    GHC.Types.Int -> Math.Term.Term -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Math.Term.Term)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Math.Term.$fShowContext_$cshow1 x))
                   s) -}
b44e7245864233b86af4dac9bf2fc883
  $fShowTypeRel :: GHC.Show.Show Math.Term.TypeRel
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Math.Term.TypeRel
                  Math.Term.$fShowTypeRel_$cshowsPrec
                  Math.Term.$fShowTypeRel_$cshow
                  Math.Term.$fShowTypeRel_$cshowList -}
17b38df1f3c5298576420e29604396ed
  $fShowTypeRel1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowTypeRel2) -}
cfd48606f2154848fda2b47209eb8152
  $fShowTypeRel2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("NOTEQ"#) -}
c378728be5254654929e95caf9e9ac06
  $fShowTypeRel3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowTypeRel4) -}
8415edf3dc68dcb6643af12f08af7d59
  $fShowTypeRel4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SUPERTYPE"#) -}
1c0f5932b8ef81188ffcb985962eb44b
  $fShowTypeRel5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowTypeRel6) -}
d650bdd73a452511d03c5eee85e93596
  $fShowTypeRel6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("SUBTYPE"#) -}
63f13c5cd994f8dd7514c833806e66b5
  $fShowTypeRel7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   Math.Term.$fShowTypeRel8) -}
5175c94a80acaacf1158867f82d28e70
  $fShowTypeRel8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("EQUIV"#) -}
b44e7245864233b86af4dac9bf2fc883
  $fShowTypeRel_$cshow :: Math.Term.TypeRel -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Math.Term.TypeRel) ->
                 case x of wild2 {
                   Math.Term.EQUIV -> Math.Term.$fShowTypeRel7
                   Math.Term.SUBTYPE -> Math.Term.$fShowTypeRel5
                   Math.Term.SUPERTYPE -> Math.Term.$fShowTypeRel3
                   Math.Term.NOTEQ -> Math.Term.$fShowTypeRel1 }) -}
b44e7245864233b86af4dac9bf2fc883
  $fShowTypeRel_$cshowList :: [Math.Term.TypeRel] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Math.Term.TypeRel]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Math.Term.TypeRel
                   Math.Term.$w$cshowsPrec2
                   ls
                   s) -}
b44e7245864233b86af4dac9bf2fc883
  $fShowTypeRel_$cshowsPrec ::
    GHC.Types.Int -> Math.Term.TypeRel -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Math.Term.TypeRel)
                   (w2 :: GHC.Base.String) ->
                 Math.Term.$w$cshowsPrec2 w1 w2) -}
4b5f8d869cf3f7e65da15407a06afca2
  $s$fEqTree :: GHC.Classes.Eq (Data.Tree.Tree Math.Term.Term)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Tree.Tree Math.Term.Term)
                  (Data.Tree.$fEqTree_$c== @ Math.Term.Term Math.Term.$fEqTerm)
                  Math.Term.$s$fEqTree_$s$fEqTree_$c/= -}
2fd260f49be15d0ee84b8ecf7b521728
  $s$fEqTree_$s$fEqTree_$c/= ::
    Data.Tree.Tree Math.Term.Term
    -> Data.Tree.Tree Math.Term.Term -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x4 :: Data.Tree.Tree Math.Term.Term)
                   (y :: Data.Tree.Tree Math.Term.Term) ->
                 case Data.Tree.$fEqTree_$c==
                        @ Math.Term.Term
                        Math.Term.$fEqTerm
                        x4
                        y of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
9f944461b50a7cf5873f96c53057dba1
  $s$wsplitS ::
    Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
    -> (# Data.Set.Internal.Set Math.Term.Term,
          Data.Set.Internal.Set Math.Term.Term #)
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [~] -}
67be7477c73d206f65abbfc27107ed33
  $sdelete_$sgo3 ::
    Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
334d6fb05de7401e775153849a31d060
  $sdifference ::
    Data.Set.Internal.Set Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [~] -}
6def346bcbf40f2a3af529d54dff954e
  $sfromList ::
    [Math.Term.Term] -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Math.Term.Term]) ->
                 case ds of wild2 {
                   [] -> Data.Set.Internal.Tip @ Math.Term.Term
                   : x ds1
                   -> case ds1 of wild3 {
                        []
                        -> case x of dt { DEFAULT ->
                           Data.Set.Internal.Bin
                             @ Math.Term.Term
                             1#
                             dt
                             (Data.Set.Internal.Tip @ Math.Term.Term)
                             (Data.Set.Internal.Tip @ Math.Term.Term) }
                        : ipv ipv1
                        -> case Math.Term.relation x ipv of wild4 {
                             DEFAULT
                             -> case x of dt { DEFAULT ->
                                Math.Term.$sfromList_go
                                  wild3
                                  (Data.Set.Internal.Bin
                                     @ Math.Term.Term
                                     1#
                                     dt
                                     (Data.Set.Internal.Tip @ Math.Term.Term)
                                     (Data.Set.Internal.Tip @ Math.Term.Term)) }
                             Math.Term.SUBTYPE
                             -> case x of dt { DEFAULT ->
                                Math.Term.$wgo2
                                  1#
                                  (Data.Set.Internal.Bin
                                     @ Math.Term.Term
                                     1#
                                     dt
                                     (Data.Set.Internal.Tip @ Math.Term.Term)
                                     (Data.Set.Internal.Tip @ Math.Term.Term))
                                  wild3 } } } }) -}
9be26edf23e80576b32db6e37aecaf68
  $sfromList_go ::
    [Math.Term.Term]
    -> Data.Set.Internal.Set Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
11c0f84f1808999350751c67701b392c
  $sinsertR_$sgo3 ::
    Math.Term.Term
    -> Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
3cc7b6f88e0a4bd044f34f34dae78fc9
  $sinsert_$sgo1 ::
    Math.Term.Term
    -> Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
072bb9aebeb5292ab27b29b125947e2f
  $smember_go3 ::
    Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
590561969764f1dd385e52e905a5558e
  $sunion ::
    Data.Set.Internal.Set (Math.Term.Term, Math.Term.TypeRel)
    -> Data.Set.Internal.Set (Math.Term.Term, Math.Term.TypeRel)
    -> Data.Set.Internal.Set (Math.Term.Term, Math.Term.TypeRel)
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
3ed3bee6e0a2f74ab37670967a9123e5
  $tc'Ap :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2897154852377329302##
                   13437887590714339626##
                   Math.Term.$trModule
                   Math.Term.$tc'Ap2
                   0#
                   Math.Term.$tc'Ap1) -}
09f46298e169adeac4572cf07489db20
  $tc'Ap1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
05414eb2533ef98809ec745ec1bc0c9b
  $tc'Ap2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Ap3) -}
5fb252bb991b27bfe42588433591c253
  $tc'Ap3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Ap"#) -}
2cb7e147d5afb35b09560628fd2ec1bf
  $tc'Coprod :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11940958102737220716##
                   9218850567110234328##
                   Math.Term.$trModule
                   Math.Term.$tc'Coprod2
                   0#
                   Math.Term.$tc'Coprod1) -}
158f390cc2f9c84d77d27719f8712900
  $tc'Coprod1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
d60a025a49e7c0ec950a93e888dd8574
  $tc'Coprod2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Coprod3) -}
d313223e2b4f964d6c127a2ba9f2358d
  $tc'Coprod3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Coprod"#) -}
65b73485af7ae33fb30e25a991557d31
  $tc'Ctx :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5970747653443792056##
                   1874773928768501650##
                   Math.Term.$trModule
                   Math.Term.$tc'Ctx2
                   0#
                   Math.Term.$tc'Ctx1) -}
3c626cd8e9410b313494de71a03b5a4b
  $tc'Ctx1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d9bf300a4cee7cc7ea9be746e2a00c2f
  $tc'Ctx2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Ctx3) -}
880950e9ca39a3bdf6cdf0029188a086
  $tc'Ctx3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Ctx"#) -}
e7b546ed129403431b2ecff5589479fd
  $tc'Def :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12880872431608559344##
                   10017171595869100090##
                   Math.Term.$trModule
                   Math.Term.$tc'Def2
                   0#
                   Math.Term.$tc'Def1) -}
6bf2272b987f3726cbb9a4ec058d4b77
  $tc'Def1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
91c7f26403e362f47821ac6bb09f606a
  $tc'Def2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Def3) -}
b4217bfdd57af8a869fc964ad1ac7c7a
  $tc'Def3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Def"#) -}
20a67a01bea15f9c370a4343bbc83b4c
  $tc'DefConst :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3645695089465243999##
                   4597347683256937431##
                   Math.Term.$trModule
                   Math.Term.$tc'DefConst2
                   0#
                   Math.Term.$tc'DefConst1) -}
12362016f21dc6284401ef07a8458268
  $tc'DefConst1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b2764b2d72ade2745e534e2650a121c4
  $tc'DefConst2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'DefConst3) -}
427cd8698079ee957083f0c4e3f20af0
  $tc'DefConst3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DefConst"#) -}
2af1f5ce1561aff36a7b82199bd1b05b
  $tc'DefEq :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   979948391737555606##
                   8813716607780760678##
                   Math.Term.$trModule
                   Math.Term.$tc'DefEq1
                   0#
                   Math.Term.$tc'Coprod1) -}
ce3d446408df521f2d70e0a4d9eb61b1
  $tc'DefEq1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'DefEq2) -}
726ee29a5039b98b9e6efc7c1d97dd22
  $tc'DefEq2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DefEq"#) -}
8b0e1f1e3f4645d9cf0f46ade71200eb
  $tc'DefType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6426979879334517146##
                   8193379366955772019##
                   Math.Term.$trModule
                   Math.Term.$tc'DefType1
                   0#
                   Math.Term.$tc'Coprod1) -}
6741355e82d7787e8f158b87844aad78
  $tc'DefType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'DefType2) -}
1730deae2fca9ff74ec50a537774712b
  $tc'DefType2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DefType"#) -}
1c2ef69dde0e307b063eb49183c01887
  $tc'EQUIV :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15872240913204848596##
                   7552317564715428729##
                   Math.Term.$trModule
                   Math.Term.$tc'EQUIV2
                   0#
                   Math.Term.$tc'EQUIV1) -}
2e5b66714f1edd39984f0a0d376b2575
  $tc'EQUIV1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
f6c0ab743326a10ead4ff3149c82bfef
  $tc'EQUIV2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'EQUIV3) -}
ba00db4aacbaa5c140dca37ae7496099
  $tc'EQUIV3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'EQUIV"#) -}
48f3e0e2dec131d9d269a8f25959cb68
  $tc'Func :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16211283857633892670##
                   5893078705181950106##
                   Math.Term.$trModule
                   Math.Term.$tc'Func1
                   0#
                   Math.Term.$tc'Coprod1) -}
4fc745a1b18b4d6f36a1962423d917c7
  $tc'Func1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Func2) -}
d1ec05d681bb15507af707229aa40b29
  $tc'Func2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Func"#) -}
9e20e7f1c6ea0378b408ee73a464eb69
  $tc'Ident :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9510828685518081714##
                   17044447723539159169##
                   Math.Term.$trModule
                   Math.Term.$tc'Ident1
                   0#
                   Math.Term.$tc'Coprod1) -}
2c9a334a5b6961abd615ec3aac870fa0
  $tc'Ident1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Ident2) -}
b7c9df9f4b4b2890c7dcae62ba4df701
  $tc'Ident2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Ident"#) -}
ee8681233d704a6c38e92b05aaf6b7ac
  $tc'Inductor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6329100989867969862##
                   16240174715272291848##
                   Math.Term.$trModule
                   Math.Term.$tc'Inductor2
                   0#
                   Math.Term.$tc'Inductor1) -}
f32869118bd2e0822b97a9a11efdd3b8
  $tc'Inductor1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
519fd6589378cc62e493122f42cc4ed1
  $tc'Inductor2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Inductor3) -}
673afe7fd2f7e4613bd205a1fa7bc543
  $tc'Inductor3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Inductor"#) -}
9db3f2f70a11839a9f1077efa65024bc
  $tc'Inl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12721406369580455362##
                   7927048713114651008##
                   Math.Term.$trModule
                   Math.Term.$tc'Inl1
                   0#
                   Math.Term.$tc'Coprod1) -}
123146f994267b200f1efa7a246164c9
  $tc'Inl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Inl2) -}
389d11c3c82191951845958a69962af4
  $tc'Inl2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Inl"#) -}
81c0927f46ec2818fe8d88eb6def4089
  $tc'Inr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7279052879054669121##
                   12743226897896273923##
                   Math.Term.$trModule
                   Math.Term.$tc'Inr1
                   0#
                   Math.Term.$tc'Coprod1) -}
cf15b38aca8c2002c7e32c585125822d
  $tc'Inr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Inr2) -}
ab94675bbe778919687fb7969113e51e
  $tc'Inr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Inr"#) -}
649fb686d13ed72063449210674f6f68
  $tc'Lambda :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14603928531725075242##
                   14597347387981072027##
                   Math.Term.$trModule
                   Math.Term.$tc'Lambda2
                   0#
                   Math.Term.$tc'Lambda1) -}
8733ac49273b7762f3dba78a80bca9bb
  $tc'Lambda1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
47a3325739133745bf4c9acf1d0d5ff6
  $tc'Lambda2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Lambda3) -}
275b2da04b4bff823b5d068ac4aec494
  $tc'Lambda3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Lambda"#) -}
15aeae505cda755f7b1792375f10506f
  $tc'NOTEQ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7913148437115909043##
                   9936953013980819459##
                   Math.Term.$trModule
                   Math.Term.$tc'NOTEQ1
                   0#
                   Math.Term.$tc'EQUIV1) -}
d6caa89ce336bc9e86b79be38fba427e
  $tc'NOTEQ1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'NOTEQ2) -}
5192df341b74fd8c16ac62c315d3c2cf
  $tc'NOTEQ2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'NOTEQ"#) -}
483b98b877df69852aac3db70bc07f32
  $tc'Nat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15558460313368405036##
                   7251899998369281688##
                   Math.Term.$trModule
                   Math.Term.$tc'Nat1
                   0#
                   Math.Term.$tc'Coprod1) -}
9c6701b183f279e7e89c7800679f1e54
  $tc'Nat1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Nat2) -}
8dfab08cdbfd9061e36cc975cd8527d5
  $tc'Nat2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Nat"#) -}
7569d155480a64b62da589cf7cbbaaa5
  $tc'Node :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4490101996156437599##
                   4381220602982073685##
                   Math.Term.$trModule
                   Math.Term.$tc'Node2
                   0#
                   Math.Term.$tc'Node1) -}
de2cd03c7e0ba9aa59ea12938aed5ec4
  $tc'Node1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
284571800415f32bb7b3edee8188ba27
  $tc'Node2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Node3) -}
2a8264e24fdd0c86d4d8621cf747bf29
  $tc'Node3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Node"#) -}
20c189fd62ed03f47a0649c4321b43d7
  $tc'Null :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17789139089225697673##
                   13159403229812602692##
                   Math.Term.$trModule
                   Math.Term.$tc'Null2
                   0#
                   Math.Term.$tc'Null1) -}
662cd5b91487a1d3b6b85d0ee73c3510
  $tc'Null1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
6fd7be06f0d8706bf52404814e9a8007
  $tc'Null2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Null3) -}
102cd5ef1cd4ffbee0fe68838de171e1
  $tc'Null3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Null"#) -}
7f53c478b086eca723a42239bb5a88cb
  $tc'One :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8799820182463995115##
                   7756838314189907061##
                   Math.Term.$trModule
                   Math.Term.$tc'One1
                   0#
                   Math.Term.$tc'Coprod1) -}
efeb69064b1f80ba15223ce93c89928b
  $tc'One1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'One2) -}
2472a7d4ca5cb355d9175e469862d744
  $tc'One2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'One"#) -}
a0bc48155cb8b7a66ecff4fe4c5affff
  $tc'Pair :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12915539010359418833##
                   11476652586684751170##
                   Math.Term.$trModule
                   Math.Term.$tc'Pair1
                   0#
                   Math.Term.$tc'Coprod1) -}
1382815a22ea4a2cb24dd7e51a96e541
  $tc'Pair1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Pair2) -}
97ace40297d2cb75d49794168c663261
  $tc'Pair2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pair"#) -}
aff5d3d60620ac9329e0fc11a892944a
  $tc'Pi :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15738349010041547754##
                   14035749837969670462##
                   Math.Term.$trModule
                   Math.Term.$tc'Pi1
                   0#
                   Math.Term.$tc'Coprod1) -}
597039e257d96720590e902c8c7ba490
  $tc'Pi1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Pi2) -}
24fe4d41cd3192b7cb6459811d9ae184
  $tc'Pi2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Pi"#) -}
b7b539fffe3b585848207653e583bb58
  $tc'Prim :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8861754910789921247##
                   9143603438581181753##
                   Math.Term.$trModule
                   Math.Term.$tc'Prim2
                   0#
                   Math.Term.$tc'Prim1) -}
fa22102dd288cc7dd6cd991415db15bd
  $tc'Prim1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d5963598a0d3c39f1ebd5c46ce2d6b27
  $tc'Prim2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Prim3) -}
df6ecf8243b13f58c6cc2bd225bc4fb6
  $tc'Prim3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Prim"#) -}
a3e271da643f1fc142f97bcc0b028a25
  $tc'Prjl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2353157939802779441##
                   18318801188271162233##
                   Math.Term.$trModule
                   Math.Term.$tc'Prjl1
                   0#
                   Math.Term.$tc'Coprod1) -}
31d6db2aa23f7219733cafc609001a99
  $tc'Prjl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Prjl2) -}
6e6a7b0c180307f552e2ae2be0fd13c7
  $tc'Prjl2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Prjl"#) -}
34404ee4d06af4fd94cce16213c5eff1
  $tc'Prjr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17969720325772136875##
                   6862845053211950160##
                   Math.Term.$trModule
                   Math.Term.$tc'Prjr1
                   0#
                   Math.Term.$tc'Coprod1) -}
ed842ce190032a3ae5113308a9e33866
  $tc'Prjr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Prjr2) -}
baf3e77b776eee8cbfded544b93b6622
  $tc'Prjr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Prjr"#) -}
18b50cf2c55e3c0922c165441499a979
  $tc'Refl :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   131530593681911067##
                   7644650837932337017##
                   Math.Term.$trModule
                   Math.Term.$tc'Refl1
                   0#
                   Math.Term.$tc'Coprod1) -}
055e7af0f5e39c5e1e79f6eb28d50940
  $tc'Refl1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Refl2) -}
700215939044f72282b736d299b0d071
  $tc'Refl2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Refl"#) -}
36a8220bc8eaf19ab765cd97b93e0fac
  $tc'SUBTYPE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   872622003632524278##
                   9064946736892725062##
                   Math.Term.$trModule
                   Math.Term.$tc'SUBTYPE1
                   0#
                   Math.Term.$tc'EQUIV1) -}
89f65944fb84e08c833da01004d2a40b
  $tc'SUBTYPE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'SUBTYPE2) -}
2be4e902706f330dbd5e05502ca0f214
  $tc'SUBTYPE2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SUBTYPE"#) -}
78fbc3767ad3145f10aeb544337ef598
  $tc'SUPERTYPE :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10621345643650573737##
                   14144688661773690330##
                   Math.Term.$trModule
                   Math.Term.$tc'SUPERTYPE1
                   0#
                   Math.Term.$tc'EQUIV1) -}
70a858159ce0ac48c5230da9a103ee85
  $tc'SUPERTYPE1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'SUPERTYPE2) -}
c62da7b99c1494e694f3ce0adb50e2b6
  $tc'SUPERTYPE2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SUPERTYPE"#) -}
166312113ea76b1a9018574899272f73
  $tc'Sigma :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8222600200090098467##
                   3816878639088268268##
                   Math.Term.$trModule
                   Math.Term.$tc'Sigma1
                   0#
                   Math.Term.$tc'Coprod1) -}
1b3a97168289294fcc5594aa52c2217c
  $tc'Sigma1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Sigma2) -}
ff4062507350cbb31e632270841e50ec
  $tc'Sigma2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Sigma"#) -}
43f704367f85684c306629f8cd474941
  $tc'Two :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14893799048259053773##
                   5525189529244760410##
                   Math.Term.$trModule
                   Math.Term.$tc'Two1
                   0#
                   Math.Term.$tc'Coprod1) -}
770e7ce38d71c201a11a52d462b843c1
  $tc'Two1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Two2) -}
a515635e6bf22eb11cc1a2cec9692374
  $tc'Two2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Two"#) -}
30d324ae4f2689df656a4e12dc0c5ca7
  $tc'U :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7558996006403742447##
                   235266697142840671##
                   Math.Term.$trModule
                   Math.Term.$tc'U2
                   0#
                   Math.Term.$tc'U1) -}
ea7d26e9fb5a1addf016a8a4780cd6b9
  $tc'U1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
cdecc8a258c2c111eb03cd6f97fc4c5a
  $tc'U2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'U3) -}
e4c5b1f4024363e9adf65ddd9309e103
  $tc'U3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'U"#) -}
24f106db3c7217ca9a3852f16e5d5e7f
  $tc'X :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4270640033758605804##
                   4397060504839882045##
                   Math.Term.$trModule
                   Math.Term.$tc'X2
                   0#
                   Math.Term.$tc'X1) -}
7c84fd1b9d18168331bdf12ed2c04d93
  $tc'X1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
6a08f4d5b7869004ab524c9fd9b71768
  $tc'X2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'X3) -}
d186d35b3f915d5fed9e8bd14857ec64
  $tc'X3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'X"#) -}
853c349717eb767a707ad002a5666541
  $tc'Zero :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5325067431240033999##
                   3183270602551586097##
                   Math.Term.$trModule
                   Math.Term.$tc'Zero1
                   0#
                   Math.Term.$tc'Coprod1) -}
68fed00cf6650693e9e296ee3551ca4b
  $tc'Zero1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tc'Zero2) -}
acbf6fca2ec006490785ba0561feb016
  $tc'Zero2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Zero"#) -}
6b24e87ae14edd4b7a5afd01f30581e0
  $tcContext :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13755666901867497447##
                   2491554076883613918##
                   Math.Term.$trModule
                   Math.Term.$tcContext1
                   0#
                   GHC.Types.krep$*) -}
507eec0e371c924150fc88785eafeeef
  $tcContext1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tcContext2) -}
15d3dda828057442e5a3c848babc5ffd
  $tcContext2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Context"#) -}
e14f4e87f888717f5ac91dd17c17a62d
  $tcInductionTree :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15729988230897729109##
                   12520560474008973846##
                   Math.Term.$trModule
                   Math.Term.$tcInductionTree1
                   0#
                   GHC.Types.krep$*) -}
a58de3a8d08b16412d9c1a45c05b83d5
  $tcInductionTree1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tcInductionTree2) -}
155d85c665020e16d3cffb4ff5d7893a
  $tcInductionTree2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("InductionTree"#) -}
e6f082628ec1177e72c64f3f5645fbbe
  $tcInductor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9191471458300630581##
                   16283446613710900944##
                   Math.Term.$trModule
                   Math.Term.$tcInductor1
                   0#
                   GHC.Types.krep$*) -}
c18c9f1533b951ca1f3be8799e5121e5
  $tcInductor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tcInductor2) -}
dd8773ed521e30317d2c0392db0799bc
  $tcInductor2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Inductor"#) -}
6ab17726587c7baab9203fee8a54955b
  $tcPrimConst :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12313271754392514667##
                   11288165421017402123##
                   Math.Term.$trModule
                   Math.Term.$tcPrimConst1
                   0#
                   GHC.Types.krep$*) -}
0cb6e80ff18ecf18d1bbae2fbdfc9c48
  $tcPrimConst1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tcPrimConst2) -}
4ae9f53b25140088dc4e1d49cbf24807
  $tcPrimConst2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("PrimConst"#) -}
b459198801c4617eaff0d15d5807d92e
  $tcTerm :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13173492972804363617##
                   7326483389163376345##
                   Math.Term.$trModule
                   Math.Term.$tcTerm1
                   0#
                   GHC.Types.krep$*) -}
6e23d6195926e67891ea14c7a1cbb537
  $tcTerm1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tcTerm2) -}
99686538c5cec9af341567fd172aedac
  $tcTerm2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Term"#) -}
eb7138494fca186ca964d4969d65d701
  $tcTypeRel :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   308492189813251175##
                   11032333003299362952##
                   Math.Term.$trModule
                   Math.Term.$tcTypeRel1
                   0#
                   GHC.Types.krep$*) -}
40161fc78967b7e252e43720c75217c0
  $tcTypeRel1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$tcTypeRel2) -}
bb7983a6908078b80a53b1683fe1373f
  $tcTypeRel2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("TypeRel"#) -}
deeb074fbe2e431492cbe9db2d1cf880
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Math.Term.$trModule3
                   Math.Term.$trModule1) -}
4713e4405353421441a3fdc9af1dffe8
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$trModule2) -}
7945ec713d581f62dd7967a5610a2be0
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Math.Term"#) -}
868fb1a20ce0c6668b256231ae10ca1e
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Math.Term.$trModule4) -}
8bf10fc8ac8923be35c7d3de7ac415d3
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("formal-types-0.0.0.1-LNuWVcA3B6I9n93ajhqv14"#) -}
2d379a2fafed7f7b0029499b692c970c
  $w$c== ::
    Math.Term.Term
    -> (Math.Term.Term -> Math.Term.Term)
    -> Math.Term.Term
    -> (Math.Term.Term -> Math.Term.Term)
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <S,U><L,1*C1(U)><S,U><L,1*C1(U)>,
     Inline: [2],
     Unfolding: (\ (ww :: Math.Term.Term)
                   (ww1 :: Math.Term.Term -> Math.Term.Term)
                   (ww2 :: Math.Term.Term)
                   (ww3 :: Math.Term.Term -> Math.Term.Term) ->
                 case Math.Term.$fEqInductor_$c==1 ww ww2 of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> Math.Term.$fEqInductor_$c==1 (ww1 ww) (ww3 ww2) }) -}
5a811a51ca264b697e2b8419685b3770
  $w$ccompare ::
    Math.Term.Term
    -> (Math.Term.Term -> Math.Term.Term)
    -> Math.Term.Term
    -> (Math.Term.Term -> Math.Term.Term)
    -> GHC.Types.Ordering
  {- Arity: 4, Strictness: <S,U><L,1*C1(U)><S,U><L,1*C1(U)>,
     Inline: [2],
     Unfolding: (\ (ww :: Math.Term.Term)
                   (ww1 :: Math.Term.Term -> Math.Term.Term)
                   (ww2 :: Math.Term.Term)
                   (ww3 :: Math.Term.Term -> Math.Term.Term) ->
                 case Math.Term.relation ww ww2 of wild2 {
                   Math.Term.EQUIV
                   -> let {
                        a :: Math.Term.Term = ww1 ww
                      } in
                      let {
                        b :: Math.Term.Term = ww3 ww2
                      } in
                      case Math.Term.$fEqInductor_$c==1 a b of wild3 {
                        GHC.Types.False
                        -> case Math.Term.$fMonoidContext_goRelation
                                  (Math.Term.alphaReduce a)
                                  (Math.Term.alphaReduce b) of wild4 {
                             Math.Term.EQUIV -> GHC.Types.EQ
                             Math.Term.SUBTYPE -> GHC.Types.LT
                             Math.Term.SUPERTYPE -> GHC.Types.GT
                             Math.Term.NOTEQ -> GHC.Types.GT }
                        GHC.Types.True -> GHC.Types.EQ }
                   Math.Term.SUBTYPE -> GHC.Types.LT
                   Math.Term.SUPERTYPE -> GHC.Types.GT
                   Math.Term.NOTEQ -> GHC.Types.GT }) -}
d2f7a8d2bcbb5d1b0dacf441d0161586
  $w$cshow ::
    Data.Set.Internal.Set Math.Term.Term
    -> Math.Term.InductionTree -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: Data.Set.Internal.Set Math.Term.Term)
                   (ww1 :: Math.Term.InductionTree) ->
                 GHC.CString.unpackAppendCString#
                   Math.Term.$fShowContext3
                   (case GHC.List.$w!!
                           @ (Data.Tree.Tree Math.Term.Term)
                           (Math.Term.$fShowContext_go ww1)
                           0# of ww2 { Data.Tree.Node ww3 ww4 ->
                    case Data.Tree.$wfmapTree
                           @ Math.Term.Term
                           @ GHC.Base.String
                           Math.Term.$fShowContext_$cshow1
                           ww3
                           ww4 of ww5 { (#,#) ww6 ww7 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (Data.OldList.unlines
                         (GHC.Base.++
                            @ [GHC.Types.Char]
                            (Data.OldList.lines ww6)
                            (Data.Tree.drawTree_drawSubTrees ww7)))
                      (GHC.CString.unpackAppendCString#
                         Math.Term.$fShowContext2
                         (case GHC.List.$w!!
                                 @ (Data.Tree.Tree Math.Term.Term)
                                 (Math.Term.$fShowContext_go
                                    (Math.Term.insertAllMT
                                       Math.Term.emptyMT
                                       (Math.Term.$fShowContext_go3
                                          (GHC.Types.[] @ Math.Term.Inductor)
                                          ww)))
                                 0# of ww8 { Data.Tree.Node ww9 ww10 ->
                          case Data.Tree.$wfmapTree
                                 @ Math.Term.Term
                                 @ GHC.Base.String
                                 Math.Term.$fShowContext_$cshow1
                                 ww9
                                 ww10 of ww11 { (#,#) ww12 ww13 ->
                          Data.OldList.unlines
                            (GHC.Base.++
                               @ [GHC.Types.Char]
                               (Data.OldList.lines ww12)
                               (Data.Tree.drawTree_drawSubTrees ww13)) } })) } })) -}
b718e2ee3250e8c0248c3ba9c23f5367
  $w$cshow1 ::
    Math.Term.Term
    -> (Math.Term.Term -> Math.Term.Term) -> GHC.Base.String
  {- Arity: 2, Strictness: <S,U><L,1*C1(U)>, Inline: [2],
     Unfolding: (\ (ww :: Math.Term.Term)
                   (ww1 :: Math.Term.Term -> Math.Term.Term) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (Math.Term.$fShowContext_$cshow1 ww)
                   (GHC.Base.++
                      @ GHC.Types.Char
                      Math.Term.$fShowInductor2
                      (Math.Term.$fShowContext_$cshow1 (ww1 ww)))) -}
96245e8924a8a0a25d6a45f11feba59a
  $w$cshowsPrec ::
    Math.Term.InductionTree -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: Math.Term.InductionTree)
                   (w1 :: GHC.Base.String) ->
                 case GHC.List.$w!!
                        @ (Data.Tree.Tree Math.Term.Term)
                        (Math.Term.$fShowContext_go w)
                        0# of ww { Data.Tree.Node ww1 ww2 ->
                 case Data.Tree.$wfmapTree
                        @ Math.Term.Term
                        @ GHC.Base.String
                        Math.Term.$fShowContext_$cshow1
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (Data.OldList.unlines
                      (GHC.Base.++
                         @ [GHC.Types.Char]
                         (Data.OldList.lines ww4)
                         (Data.Tree.drawTree_drawSubTrees ww5)))
                   w1 } }) -}
f779d9ff6d7579897070b0c3eb2c938e
  $w$cshowsPrec1 ::
    Math.Term.Term
    -> (Math.Term.Term -> Math.Term.Term)
    -> GHC.Base.String
    -> [GHC.Types.Char]
  {- Arity: 3, Strictness: <S,U><L,1*C1(U)><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: Math.Term.Term)
                   (ww1 :: Math.Term.Term -> Math.Term.Term)
                   (w :: GHC.Base.String) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (Math.Term.$fShowContext_$cshow1 ww)
                   (GHC.Base.++
                      @ GHC.Types.Char
                      Math.Term.$fShowInductor2
                      (GHC.Base.++
                         @ GHC.Types.Char
                         (Math.Term.$fShowContext_$cshow1 (ww1 ww))
                         w))) -}
b44e7245864233b86af4dac9bf2fc883
  $w$cshowsPrec2 ::
    Math.Term.TypeRel -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: Math.Term.TypeRel) (w1 :: GHC.Base.String) ->
                 case w of wild2 {
                   Math.Term.EQUIV
                   -> GHC.Base.++ @ GHC.Types.Char Math.Term.$fShowTypeRel7 w1
                   Math.Term.SUBTYPE
                   -> GHC.Base.++ @ GHC.Types.Char Math.Term.$fShowTypeRel5 w1
                   Math.Term.SUPERTYPE
                   -> GHC.Base.++ @ GHC.Types.Char Math.Term.$fShowTypeRel3 w1
                   Math.Term.NOTEQ
                   -> GHC.Base.++ @ GHC.Types.Char Math.Term.$fShowTypeRel1 w1 }) -}
d0b88f05caf34de0ef4228746e5fad36
  $w$sgo3 ::
    Math.Term.Inductor
    -> Math.Term.Term
    -> (Math.Term.Term -> Math.Term.Term)
    -> Data.Set.Internal.Set Math.Term.Inductor
    -> Data.Set.Internal.Set Math.Term.Inductor
  {- Arity: 4, Strictness: <L,U><L,U><L,C(U)><S,1*U>, Inline: [2] -}
68b4ef5d1fa0787d2d71a2f5e8867701
  $wapplyDefs ::
    Data.Set.Internal.Set Math.Term.Term
    -> Math.Term.InductionTree
    -> (# Data.Set.Internal.Set Math.Term.Term,
          Math.Term.InductionTree #)
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: Data.Set.Internal.Set Math.Term.Term)
                   (ww1 :: Math.Term.InductionTree) ->
                 letrec {
                   $wgo4 :: [Math.Term.Term]
                            -> (# Data.Set.Internal.Set Math.Term.Term,
                                  Math.Term.InductionTree #)
                     {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
                   = \ (w :: [Math.Term.Term]) ->
                     case w of wild2 {
                       []
                       -> case Math.Term.applyDefs1
                          ret_ty (# Data.Set.Internal.Set Math.Term.Term,
                                    Math.Term.InductionTree #)
                          of {}
                       : t ds
                       -> case ds of wild3 {
                            [] -> Math.Term.$wnewType t ww ww1
                            : ipv ipv1
                            -> case $wgo4 wild3 of ww2 { (#,#) ww3 ww4 ->
                               Math.Term.$wnewType t ww3 ww4 } } }
                 } in
                 $wgo4
                   (Data.Set.Internal.$fDataSet_go
                      @ Math.Term.Term
                      (GHC.Types.[] @ Math.Term.Term)
                      ww)) -}
bc331e279fd749243aaf27d51fb63570
  $wapplyMorphs ::
    Data.Set.Internal.Set Math.Term.Term
    -> Math.Term.InductionTree
    -> (# Data.Set.Internal.Set Math.Term.Term,
          Math.Term.InductionTree #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: Data.Set.Internal.Set Math.Term.Term)
                   (ww1 :: Math.Term.InductionTree) ->
                 letrec {
                   $wgo4 :: [Math.Term.Term]
                            -> (# Data.Set.Internal.Set Math.Term.Term,
                                  Math.Term.InductionTree #)
                     {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
                   = \ (w :: [Math.Term.Term]) ->
                     case w of wild2 {
                       []
                       -> case Math.Term.applyMorphs1
                          ret_ty (# Data.Set.Internal.Set Math.Term.Term,
                                    Math.Term.InductionTree #)
                          of {}
                       : t ds
                       -> case ds of wild3 {
                            [] -> (# Math.Term.$wpathInduction ww1 t, ww1 #)
                            : ipv ipv1
                            -> case $wgo4
                                      (GHC.Types.:
                                         @ Math.Term.Term
                                         t
                                         (GHC.Types.[] @ Math.Term.Term)) of ww2 { (#,#) ww3 ww4 ->
                               case $wgo4 wild3 of ww5 { (#,#) ww6 ww7 ->
                               (# Math.Term.$fMonoidContext_$sunion ww3 ww6,
                                  Math.Term.$fMonoidContext_$c<>1 ww4 ww7 #) } } } }
                 } in
                 $wgo4
                   (Data.Set.Internal.$fDataSet_go
                      @ Math.Term.Term
                      (GHC.Types.[] @ Math.Term.Term)
                      ww)) -}
9eaffd0fc7be05706c1fe963ecb4539e
  $wdepth :: Math.Term.Term -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2] -}
87ae79d366de51f317b32e5b39ddcb06
  $wgetRelated ::
    Math.Term.TypeRel
    -> Math.Term.Term
    -> Math.Term.InductionTree
    -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [2],
     Unfolding: (\ (w :: Math.Term.TypeRel)
                   (w1 :: Math.Term.Term)
                   (ww :: Math.Term.InductionTree) ->
                 letrec {
                   go8 :: Data.Set.Internal.Set Math.Term.Term
                          -> Math.Term.Term
                          -> Math.Term.InductionTree
                          -> Data.Set.Internal.Set Math.Term.Term
                     {- Arity: 3, Strictness: <S,U><L,U><S,1*U> -}
                   = \ (ls :: Data.Set.Internal.Set Math.Term.Term)
                       (tt :: Math.Term.Term)
                       (ds :: Math.Term.InductionTree) ->
                     case ds of wild2 {
                       Math.Term.Null -> ls
                       Math.Term.Node fs m l r
                       -> let {
                            $j :: Data.Set.Internal.Set Math.Term.Term <join 0>
                            = Math.Term.$fMonoidContext_$sunion (go8 ls tt l) (go8 ls tt r)
                          } in
                          let {
                            $j1 :: Data.Set.Internal.Set Math.Term.Term <join 0>
                            = case m of dt { DEFAULT ->
                              Math.Term.$fMonoidContext_$sunion
                                (Data.Set.Internal.Bin
                                   @ Math.Term.Term
                                   1#
                                   dt
                                   (Data.Set.Internal.Tip @ Math.Term.Term)
                                   (Data.Set.Internal.Tip @ Math.Term.Term))
                                (Math.Term.$fMonoidContext_$sunion (go8 ls tt l) (go8 ls tt r)) }
                          } in
                          case w of wild3 {
                            Math.Term.EQUIV
                            -> case Math.Term.relation tt m of wild4 {
                                 DEFAULT -> $j Math.Term.EQUIV -> $j1 }
                            Math.Term.SUBTYPE
                            -> case Math.Term.relation tt m of wild4 {
                                 DEFAULT -> $j Math.Term.SUBTYPE -> $j1 }
                            Math.Term.SUPERTYPE
                            -> case Math.Term.relation tt m of wild4 {
                                 DEFAULT -> $j Math.Term.SUPERTYPE -> $j1 }
                            Math.Term.NOTEQ
                            -> case Math.Term.relation tt m of wild4 {
                                 DEFAULT -> $j Math.Term.NOTEQ -> $j1 } } }
                 } in
                 go8 (Data.Set.Internal.Tip @ Math.Term.Term) w1 ww) -}
869cdeb95cd6029378befa2ddccb378d
  $wgo ::
    [Math.Term.Context]
    -> (# Data.Set.Internal.Set Math.Term.Term,
          Math.Term.InductionTree #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
869cdeb95cd6029378befa2ddccb378d
  $wgo1 ::
    Data.Set.Internal.Set Math.Term.Term
    -> Math.Term.InductionTree
    -> [Math.Term.Context]
    -> (# Data.Set.Internal.Set Math.Term.Term,
          Math.Term.InductionTree #)
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [2] -}
57cd50d9ccbb109cf5f26d360b8a85a7
  $wgo2 ::
    GHC.Prim.Int#
    -> Data.Set.Internal.Set Math.Term.Term
    -> [Math.Term.Term]
    -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [2] -}
0b0f8c7d44c30af0ae74985b933cbd20
  $wgo3 ::
    GHC.Prim.Int#
    -> Data.Set.Internal.Set Math.Term.Inductor
    -> [Math.Term.Inductor]
    -> Data.Set.Internal.Set Math.Term.Inductor
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [2] -}
bb979f9f5fd2cdf93c65b9f14f590d5e
  $widentityFunctorLaw1 ::
    Math.Term.Term -> (# Math.Term.Term, Math.Term.Term #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT
                   -> case Math.Term.identityFunctorLaw10
                      ret_ty (# Math.Term.Term, Math.Term.Term #)
                      of {}
                   Math.Term.Ap a ds
                   -> case ds of wild3 {
                        DEFAULT
                        -> case Math.Term.identityFunctorLaw10
                           ret_ty (# Math.Term.Term, Math.Term.Term #)
                           of {}
                        Math.Term.Ap ds1 c
                        -> case ds1 of wild4 {
                             DEFAULT
                             -> case Math.Term.identityFunctorLaw10
                                ret_ty (# Math.Term.Term, Math.Term.Term #)
                                of {}
                             Math.Term.Ap ds2 b
                             -> case ds2 of wild5 {
                                  DEFAULT
                                  -> case Math.Term.identityFunctorLaw10
                                     ret_ty (# Math.Term.Term, Math.Term.Term #)
                                     of {}
                                  Math.Term.Prim ds3
                                  -> case ds3 of wild6 {
                                       DEFAULT
                                       -> case Math.Term.identityFunctorLaw10
                                          ret_ty (# Math.Term.Term, Math.Term.Term #)
                                          of {}
                                       Math.Term.Ident
                                       -> (# Math.Term.Ap Math.Term.reflElim2 (Math.Term.Ap a b),
                                             Math.Term.Ap a c #) } } } } }) -}
d831c3d6313795cfc78192921718188f
  $widentityFunctorLaw2 ::
    Math.Term.Term -> (# Math.Term.Term, Math.Term.Term #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT
                   -> case Math.Term.identityFunctorLaw5
                      ret_ty (# Math.Term.Term, Math.Term.Term #)
                      of {}
                   Math.Term.Ap ds c
                   -> case ds of wild3 {
                        DEFAULT
                        -> case Math.Term.identityFunctorLaw5
                           ret_ty (# Math.Term.Term, Math.Term.Term #)
                           of {}
                        Math.Term.Ap ds1 b
                        -> case ds1 of wild4 {
                             DEFAULT
                             -> case Math.Term.identityFunctorLaw5
                                ret_ty (# Math.Term.Term, Math.Term.Term #)
                                of {}
                             Math.Term.Ap ds2 a
                             -> case ds2 of wild5 {
                                  DEFAULT
                                  -> case Math.Term.identityFunctorLaw5
                                     ret_ty (# Math.Term.Term, Math.Term.Term #)
                                     of {}
                                  Math.Term.Prim ds3
                                  -> case ds3 of wild6 {
                                       DEFAULT
                                       -> case Math.Term.identityFunctorLaw5
                                          ret_ty (# Math.Term.Term, Math.Term.Term #)
                                          of {}
                                       Math.Term.Ident
                                       -> (# Math.Term.Ap Math.Term.reflElim2 (Math.Term.Ap a c),
                                             Math.Term.Ap b c #) } } } } }) -}
13d58a8d516baf4d3a8047cde683e08c
  $winduct ::
    Math.Term.Term
    -> (Math.Term.Term -> Math.Term.Term)
    -> Math.Term.Term
    -> GHC.Maybe.Maybe Math.Term.Term
  {- Arity: 3, Strictness: <S,U><L,1*C1(U)><S,U>, Inline: [2],
     Unfolding: (\ (ww :: Math.Term.Term)
                   (ww1 :: Math.Term.Term -> Math.Term.Term)
                   (w :: Math.Term.Term) ->
                 case Math.Term.relation w ww of wild2 {
                   DEFAULT -> GHC.Maybe.Just @ Math.Term.Term (ww1 w)
                   Math.Term.SUPERTYPE -> GHC.Maybe.Nothing @ Math.Term.Term
                   Math.Term.NOTEQ -> GHC.Maybe.Nothing @ Math.Term.Term }) -}
947ae987c5094c1320fc36b55d97780a
  $wintros ::
    Data.Set.Internal.Set Math.Term.Term
    -> Math.Term.InductionTree
    -> [Math.Term.Term]
    -> (# Data.Set.Internal.Set Math.Term.Term,
          Math.Term.InductionTree #)
  {- Arity: 3, Strictness: <L,1*U><L,U><S,1*U>, Inline: [2] -}
a2df674b22a97062e1fb9420e8c50dab
  $wnatnum :: GHC.Prim.Int# -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
e78afceb0b0bd59ae422bd6533c604e7
  $wnewIdents ::
    Data.Set.Internal.Set Math.Term.Term
    -> Math.Term.InductionTree -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2],
     Unfolding: (\ (ww :: Data.Set.Internal.Set Math.Term.Term)
                   (ww1 :: Math.Term.InductionTree) ->
                 letrec {
                   go8 :: Data.Set.Internal.Set Math.Term.Term
                          -> Data.Set.Internal.Set Math.Term.Term
                          -> Data.Set.Internal.Set Math.Term.Term
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (z' :: Data.Set.Internal.Set Math.Term.Term)
                       (ds :: Data.Set.Internal.Set Math.Term.Term) ->
                     case ds of wild2 {
                       Data.Set.Internal.Bin dt x l r
                       -> go8
                            (Math.Term.$fMonoidContext_$sunion
                               (Math.Term.$wpathInduction ww1 x)
                               (go8 z' r))
                            l
                       Data.Set.Internal.Tip -> z' }
                 } in
                 go8 (Data.Set.Internal.Tip @ Math.Term.Term) ww) -}
10680ad19fab4d2e575d0413cd77f584
  $wnewType ::
    Math.Term.Term
    -> Data.Set.Internal.Set Math.Term.Term
    -> Math.Term.InductionTree
    -> (# Data.Set.Internal.Set Math.Term.Term,
          Math.Term.InductionTree #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [2] -}
b1e13a5b28e20ea699f01fcfcf3342a8
  $wnewTypes ::
    Data.Set.Internal.Set Math.Term.Term
    -> Math.Term.InductionTree
    -> [Math.Term.Term]
    -> (# Data.Set.Internal.Set Math.Term.Term,
          Math.Term.InductionTree #)
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [2] -}
019205702fa7be9cd0c95ce055a829f5
  $wnumnat :: Math.Term.Term -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2] -}
9fb0647bb0552fc2fd68458d26a6b30c
  $wpathInduction ::
    Math.Term.InductionTree
    -> Math.Term.Term -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <S,U><S,1*U>, Inline: [2] -}
7c35b0f0ecf71c63a97098b82405c4b2
  $wpiCoprodComp ::
    Math.Term.Term -> (# Math.Term.Term, Math.Term.Term #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT
                   -> case Math.Term.piCoprodComp1
                      ret_ty (# Math.Term.Term, Math.Term.Term #)
                      of {}
                   Math.Term.Ap ds ds1
                   -> case ds of wild3 {
                        DEFAULT
                        -> case Math.Term.piCoprodComp1
                           ret_ty (# Math.Term.Term, Math.Term.Term #)
                           of {}
                        Math.Term.Ap ds2 ds3
                        -> case ds2 of wild4 {
                             DEFAULT
                             -> case Math.Term.piCoprodComp1
                                ret_ty (# Math.Term.Term, Math.Term.Term #)
                                of {}
                             Math.Term.Prim ds4
                             -> case ds4 of wild5 {
                                  DEFAULT
                                  -> case Math.Term.piCoprodComp1
                                     ret_ty (# Math.Term.Term, Math.Term.Term #)
                                     of {}
                                  Math.Term.Pi
                                  -> case ds3 of wild6 {
                                       DEFAULT
                                       -> case Math.Term.piCoprodComp1
                                          ret_ty (# Math.Term.Term, Math.Term.Term #)
                                          of {}
                                       Math.Term.Ap ds5 y
                                       -> case ds5 of wild7 {
                                            DEFAULT
                                            -> case Math.Term.piCoprodComp1
                                               ret_ty (# Math.Term.Term, Math.Term.Term #)
                                               of {}
                                            Math.Term.Ap ds6 x
                                            -> case ds6 of wild8 {
                                                 DEFAULT
                                                 -> case Math.Term.piCoprodComp1
                                                    ret_ty (# Math.Term.Term, Math.Term.Term #)
                                                    of {}
                                                 Math.Term.Prim ds7
                                                 -> case ds7 of wild9 {
                                                      DEFAULT
                                                      -> case Math.Term.piCoprodComp1
                                                         ret_ty (# Math.Term.Term, Math.Term.Term #)
                                                         of {}
                                                      Math.Term.Coprod
                                                      -> case ds1 of wild10 {
                                                           DEFAULT
                                                           -> case Math.Term.piCoprodComp1
                                                              ret_ty (# Math.Term.Term,
                                                                        Math.Term.Term #)
                                                              of {}
                                                           Math.Term.Ap ds8 g1
                                                           -> case ds8 of wild11 {
                                                                DEFAULT
                                                                -> case Math.Term.piCoprodComp1
                                                                   ret_ty (# Math.Term.Term,
                                                                             Math.Term.Term #)
                                                                   of {}
                                                                Math.Term.Ap ds9 g0
                                                                -> case ds9 of wild12 {
                                                                     DEFAULT
                                                                     -> case Math.Term.piCoprodComp1
                                                                        ret_ty (# Math.Term.Term,
                                                                                  Math.Term.Term #)
                                                                        of {}
                                                                     Math.Term.Prim ds10
                                                                     -> case ds10 of wild13 {
                                                                          DEFAULT
                                                                          -> case Math.Term.piCoprodComp1
                                                                             ret_ty (# Math.Term.Term,
                                                                                       Math.Term.Term #)
                                                                             of {}
                                                                          Math.Term.Pair
                                                                          -> (# Math.Term.Ap
                                                                                  Math.Term.anyCoprod2
                                                                                  (Math.Term.Ap
                                                                                     g0
                                                                                     x),
                                                                                Math.Term.Ap
                                                                                  g1
                                                                                  y #) } } } } } }
                                            Math.Term.Prim ds6
                                            -> case ds6 of wild8 {
                                                 DEFAULT
                                                 -> case Math.Term.piCoprodComp1
                                                    ret_ty (# Math.Term.Term, Math.Term.Term #)
                                                    of {}
                                                 Math.Term.Inl
                                                 -> case ds1 of wild9 {
                                                      DEFAULT
                                                      -> case Math.Term.piCoprodComp1
                                                         ret_ty (# Math.Term.Term, Math.Term.Term #)
                                                         of {}
                                                      Math.Term.Ap ds7 g1
                                                      -> case ds7 of wild10 {
                                                           DEFAULT
                                                           -> case Math.Term.piCoprodComp1
                                                              ret_ty (# Math.Term.Term,
                                                                        Math.Term.Term #)
                                                              of {}
                                                           Math.Term.Ap ds8 g0
                                                           -> case ds8 of wild11 {
                                                                DEFAULT
                                                                -> case Math.Term.piCoprodComp1
                                                                   ret_ty (# Math.Term.Term,
                                                                             Math.Term.Term #)
                                                                   of {}
                                                                Math.Term.Prim ds9
                                                                -> case ds9 of wild12 {
                                                                     DEFAULT
                                                                     -> case Math.Term.piCoprodComp1
                                                                        ret_ty (# Math.Term.Term,
                                                                                  Math.Term.Term #)
                                                                        of {}
                                                                     Math.Term.Pair
                                                                     -> (# g0, y #) } } } }
                                                 Math.Term.Inr
                                                 -> case ds1 of wild9 {
                                                      DEFAULT
                                                      -> case Math.Term.piCoprodComp1
                                                         ret_ty (# Math.Term.Term, Math.Term.Term #)
                                                         of {}
                                                      Math.Term.Ap ds7 g1
                                                      -> case ds7 of wild10 {
                                                           DEFAULT
                                                           -> case Math.Term.piCoprodComp1
                                                              ret_ty (# Math.Term.Term,
                                                                        Math.Term.Term #)
                                                              of {}
                                                           Math.Term.Ap ds8 g0
                                                           -> case ds8 of wild11 {
                                                                DEFAULT
                                                                -> case Math.Term.piCoprodComp1
                                                                   ret_ty (# Math.Term.Term,
                                                                             Math.Term.Term #)
                                                                   of {}
                                                                Math.Term.Prim ds9
                                                                -> case ds9 of wild12 {
                                                                     DEFAULT
                                                                     -> case Math.Term.piCoprodComp1
                                                                        ret_ty (# Math.Term.Term,
                                                                                  Math.Term.Term #)
                                                                        of {}
                                                                     Math.Term.Pair
                                                                     -> (# g1,
                                                                           y #) } } } } } } } } } } }) -}
e049b8acfd7ede310b7f1bda62c98b7c
  $wpiSigmaComp ::
    Math.Term.Term -> (# Math.Term.Term, Math.Term.Term #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT
                   -> case Math.Term.piSigmaComp1
                      ret_ty (# Math.Term.Term, Math.Term.Term #)
                      of {}
                   Math.Term.Ap ds c
                   -> case ds of wild3 {
                        DEFAULT
                        -> case Math.Term.piSigmaComp1
                           ret_ty (# Math.Term.Term, Math.Term.Term #)
                           of {}
                        Math.Term.Ap ds1 ds2
                        -> case ds1 of wild4 {
                             DEFAULT
                             -> case Math.Term.piSigmaComp1
                                ret_ty (# Math.Term.Term, Math.Term.Term #)
                                of {}
                             Math.Term.Prim ds3
                             -> case ds3 of wild5 {
                                  DEFAULT
                                  -> case Math.Term.piSigmaComp1
                                     ret_ty (# Math.Term.Term, Math.Term.Term #)
                                     of {}
                                  Math.Term.Pi
                                  -> case ds2 of wild6 {
                                       DEFAULT
                                       -> case Math.Term.piSigmaComp1
                                          ret_ty (# Math.Term.Term, Math.Term.Term #)
                                          of {}
                                       Math.Term.Ap ds4 y
                                       -> case ds4 of wild7 {
                                            DEFAULT
                                            -> case Math.Term.piSigmaComp1
                                               ret_ty (# Math.Term.Term, Math.Term.Term #)
                                               of {}
                                            Math.Term.Ap ds5 x
                                            -> case ds5 of wild8 {
                                                 DEFAULT
                                                 -> case Math.Term.piSigmaComp1
                                                    ret_ty (# Math.Term.Term, Math.Term.Term #)
                                                    of {}
                                                 Math.Term.Prim ds6
                                                 -> case ds6 of wild9 {
                                                      DEFAULT
                                                      -> case Math.Term.piSigmaComp1
                                                         ret_ty (# Math.Term.Term, Math.Term.Term #)
                                                         of {}
                                                      Math.Term.Sigma
                                                      -> (# Math.Term.Ap Math.Term.bind1 x,
                                                            Math.Term.Ap
                                                              (Math.Term.Ap Math.Term.bind1 y)
                                                              c #)
                                                      Math.Term.Pair
                                                      -> (# Math.Term.Ap Math.Term.bind1 x,
                                                            Math.Term.Ap
                                                              (Math.Term.Ap Math.Term.bind1 y)
                                                              c #) } } }
                                       Math.Term.Def ds4 xs
                                       -> case ds4 of wild7 {
                                            DEFAULT
                                            -> case Math.Term.piSigmaComp1
                                               ret_ty (# Math.Term.Term, Math.Term.Term #)
                                               of {}
                                            Math.Term.Ap ds5 ds6
                                            -> case ds5 of wild8 {
                                                 DEFAULT
                                                 -> case Math.Term.piSigmaComp1
                                                    ret_ty (# Math.Term.Term, Math.Term.Term #)
                                                    of {}
                                                 Math.Term.Ap ds7 ds8
                                                 -> case ds7 of wild9 {
                                                      DEFAULT
                                                      -> case Math.Term.piSigmaComp1
                                                         ret_ty (# Math.Term.Term, Math.Term.Term #)
                                                         of {}
                                                      Math.Term.Prim ds9
                                                      -> case ds9 of wild10 {
                                                           DEFAULT
                                                           -> case Math.Term.piSigmaComp1
                                                              ret_ty (# Math.Term.Term,
                                                                        Math.Term.Term #)
                                                              of {}
                                                           Math.Term.Sigma
                                                           -> case ds8 of wild11 {
                                                                DEFAULT
                                                                -> case Math.Term.piSigmaComp1
                                                                   ret_ty (# Math.Term.Term,
                                                                             Math.Term.Term #)
                                                                   of {}
                                                                Math.Term.U
                                                                -> case ds6 of wild12 {
                                                                     DEFAULT
                                                                     -> case Math.Term.piSigmaComp1
                                                                        ret_ty (# Math.Term.Term,
                                                                                  Math.Term.Term #)
                                                                        of {}
                                                                     Math.Term.U
                                                                     -> (# Math.Term.piType4,
                                                                           Math.Term.Ap
                                                                             Math.Term.piType4
                                                                             c #) } } } } } } } } } } }) -}
eefdad33df721a3d0d151c138409a48d
  $wsigmaComp1 ::
    Math.Term.Term -> (# Math.Term.Term, Math.Term.Term #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT
                   -> case Math.Term.sigmaComp2 wild2
                      ret_ty (# Math.Term.Term, Math.Term.Term #)
                      of {}
                   Math.Term.Ap ds b
                   -> case ds of wild3 {
                        DEFAULT
                        -> case Math.Term.sigmaComp2 wild2
                           ret_ty (# Math.Term.Term, Math.Term.Term #)
                           of {}
                        Math.Term.Ap ds1 a
                        -> case ds1 of wild4 {
                             DEFAULT
                             -> case Math.Term.sigmaComp2 wild2
                                ret_ty (# Math.Term.Term, Math.Term.Term #)
                                of {}
                             Math.Term.Prim ds2
                             -> case ds2 of wild5 {
                                  DEFAULT
                                  -> case Math.Term.sigmaComp2 wild2
                                     ret_ty (# Math.Term.Term, Math.Term.Term #)
                                     of {}
                                  Math.Term.Sigma
                                  -> (# Math.Term.Ap Math.Term.$fMonoidTerm1 a,
                                        Math.Term.bind a b #) } } } }) -}
2882304b732bbbb59e0512149e7574d2
  $wsigmaInductor2 ::
    Math.Term.Term -> (# Math.Term.Term, Math.Term.Term #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT
                   -> case Math.Term.sigmaInductor8
                      ret_ty (# Math.Term.Term, Math.Term.Term #)
                      of {}
                   Math.Term.Ap ds ds1
                   -> case ds of wild3 {
                        DEFAULT
                        -> case Math.Term.sigmaInductor8
                           ret_ty (# Math.Term.Term, Math.Term.Term #)
                           of {}
                        Math.Term.Ap ds2 a
                        -> case ds2 of wild4 {
                             DEFAULT
                             -> case Math.Term.sigmaInductor8
                                ret_ty (# Math.Term.Term, Math.Term.Term #)
                                of {}
                             Math.Term.Prim ds3
                             -> case ds3 of wild5 {
                                  DEFAULT
                                  -> case Math.Term.sigmaInductor8
                                     ret_ty (# Math.Term.Term, Math.Term.Term #)
                                     of {}
                                  Math.Term.Pair
                                  -> case ds1 of wild6 {
                                       DEFAULT
                                       -> case Math.Term.sigmaInductor8
                                          ret_ty (# Math.Term.Term, Math.Term.Term #)
                                          of {}
                                       Math.Term.Lambda x b
                                       -> (# Math.Term.Ap Math.Term.sigmaType4 a,
                                             Math.Term.substitution
                                               (Math.Term.X x)
                                               b
                                               a #) } } } } }) -}
b3cf6a050291be640d8e4b8b4c8da819
  $wsigmaInductor3 ::
    Math.Term.Term -> (# Math.Term.Term, Math.Term.Term #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT
                   -> case Math.Term.sigmaInductor5
                      ret_ty (# Math.Term.Term, Math.Term.Term #)
                      of {}
                   Math.Term.Ap ds ds1
                   -> case ds of wild3 {
                        DEFAULT
                        -> case Math.Term.sigmaInductor5
                           ret_ty (# Math.Term.Term, Math.Term.Term #)
                           of {}
                        Math.Term.Ap ds2 a
                        -> case ds2 of wild4 {
                             DEFAULT
                             -> case Math.Term.sigmaInductor5
                                ret_ty (# Math.Term.Term, Math.Term.Term #)
                                of {}
                             Math.Term.Prim ds3
                             -> case ds3 of wild5 {
                                  DEFAULT
                                  -> case Math.Term.sigmaInductor5
                                     ret_ty (# Math.Term.Term, Math.Term.Term #)
                                     of {}
                                  Math.Term.Pair
                                  -> case ds1 of wild6 {
                                       DEFAULT
                                       -> case Math.Term.sigmaInductor5
                                          ret_ty (# Math.Term.Term, Math.Term.Term #)
                                          of {}
                                       Math.Term.Ap ds4 b
                                       -> case ds4 of wild7 {
                                            DEFAULT
                                            -> case Math.Term.sigmaInductor5
                                               ret_ty (# Math.Term.Term, Math.Term.Term #)
                                               of {}
                                            Math.Term.Ap ds5 x
                                            -> case ds5 of wild8 {
                                                 DEFAULT
                                                 -> case Math.Term.sigmaInductor5
                                                    ret_ty (# Math.Term.Term, Math.Term.Term #)
                                                    of {}
                                                 Math.Term.Prim ds6
                                                 -> case ds6 of wild9 {
                                                      DEFAULT
                                                      -> case Math.Term.sigmaInductor5
                                                         ret_ty (# Math.Term.Term, Math.Term.Term #)
                                                         of {}
                                                      Math.Term.Pi
                                                      -> (# Math.Term.Ap Math.Term.sigmaType4 a,
                                                            Math.Term.substitution
                                                              x
                                                              b
                                                              a #) } } } } } } } }) -}
16a3db79812b3171162f551fbed7be35
  $wsplitInt :: GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [2] -}
e838568481428b374f9eaf4442609567
  $wsubscript :: GHC.Prim.Int# -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case GHC.Prim.>=# ww 0# of lwild {
                   DEFAULT -> Math.Term.indX_go (Math.Term.$wsplitInt ww)
                   1#
                   -> case GHC.Prim.<# ww 10# of lwild1 {
                        DEFAULT -> Math.Term.indX_go (Math.Term.$wsplitInt ww)
                        1# -> GHC.List.$w!! @ [GHC.Types.Char] Math.Term.indX1 ww } }) -}
6c333fbbaaaf24e36df37a3f94ec66b8
  $wtypeReduce ::
    Math.Term.Term -> (# Math.Term.Term, [Math.Term.Term] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT
                   -> case Math.Term.typeReduce1 wild2
                      ret_ty (# Math.Term.Term, [Math.Term.Term] #)
                      of {}
                   Math.Term.Ap ds b
                   -> case ds of wild3 {
                        DEFAULT
                        -> case Math.Term.typeReduce1 wild2
                           ret_ty (# Math.Term.Term, [Math.Term.Term] #)
                           of {}
                        Math.Term.Ap ds1 a
                        -> case ds1 of wild4 {
                             DEFAULT
                             -> case Math.Term.typeReduce1 wild2
                                ret_ty (# Math.Term.Term, [Math.Term.Term] #)
                                of {}
                             Math.Term.Prim ds2
                             -> case ds2 of wild5 {
                                  DEFAULT
                                  -> case Math.Term.typeReduce1 wild2
                                     ret_ty (# Math.Term.Term, [Math.Term.Term] #)
                                     of {}
                                  Math.Term.DefType
                                  -> case Math.Term.relation a b of wild6 {
                                       DEFAULT
                                       -> (# b,
                                             GHC.Types.:
                                               @ Math.Term.Term
                                               a
                                               (GHC.Types.[] @ Math.Term.Term) #)
                                       Math.Term.SUBTYPE
                                       -> (# Math.Term.one4, Math.Term.one1 #) } } } } }) -}
b06133e99027dca09aa19fc8e10d9f55
  (-->) :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (y :: Math.Term.Term) ->
                 Math.Term.Ap (Math.Term.Ap Math.Term.-->1 x) y) -}
f528a09be1c9f75446c9335a68d3e706
  -->1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Func) -}
ab7421ec25351d01e8c473c1d1a72450
  (.$) :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (0, True, True) Math.Term.Ap -}
220e47f7c7630fb7d9540eccc8cb85be
  (.:) :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Math.Term.Term) (b :: Math.Term.Term) ->
                 Math.Term.Ap (Math.Term.Ap Math.Term..:1 a) b) -}
de52ec6c4ee2e72ddb409c51e1fefeb0
  .:1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.DefType) -}
c1cdc51c16bd3ba4ae2736af816edc90
  (.=) :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (y :: Math.Term.Term) ->
                 Math.Term.Ap (Math.Term.Ap Math.Term..=1 x) y) -}
783066214337bc65bcc995dc12513d3e
  .=1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.DefEq) -}
869cdeb95cd6029378befa2ddccb378d
  data Context
    = Ctx (Data.Set.Internal.Set Math.Term.Term)
          Math.Term.InductionTree
96245e8924a8a0a25d6a45f11feba59a
  data InductionTree
    = Null
    | Node [Math.Term.Term -> Math.Term.Term]
           Math.Term.Term
           Math.Term.InductionTree
           Math.Term.InductionTree
f0d52955e004c3f2895d7ad992cc5581
  data Inductor
    = Inductor Math.Term.Term (Math.Term.Term -> Math.Term.Term)
8b99933ee4d6b7dc1ae244851d0cd05f
  data PrimConst
    = DefConst GHC.Base.String
    | Zero
    | One
    | Two
    | Pi
    | Sigma
    | Pair
    | Coprod
    | Inl
    | Inr
    | Prjl
    | Prjr
    | DefType
    | DefEq
    | Func
    | Refl
    | Ident
    | Nat
cb71c41fabac6a5ef20c9f02bd912331
  data Term
    = U
    | X GHC.Base.String
    | Lambda GHC.Base.String Math.Term.Term
    | Ap Math.Term.Term Math.Term.Term
    | Prim Math.Term.PrimConst
    | Def Math.Term.Term [Math.Term.Term]
b44e7245864233b86af4dac9bf2fc883
  data TypeRel = EQUIV | SUBTYPE | SUPERTYPE | NOTEQ
5b05e5b3c0e8e1255c95dca458871ec8
  addTypes ::
    Math.Term.Context -> [Math.Term.Term] -> Math.Term.Context
  {- Arity: 2, Strictness: <S,1*U(1*U,U)><S,1*U>m,
     Unfolding: InlineRule (0, True, True) Math.Term.intros -}
13624b7331e02e2fce919d66ac69da17
  alpha :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
cb71c41fabac6a5ef20c9f02bd912331
  alphaReduce :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (t :: Math.Term.Term) ->
                 Math.Term.alphaReduce_go
                   t
                   (Data.Set.Internal.$fDataSet_go
                      @ Math.Term.Term
                      (GHC.Types.[] @ Math.Term.Term)
                      (Math.Term.boundVars t))
                   Math.Term.alphaReduce1) -}
0360dbe11fb79b7c0b07ba05874bb49a
  alphaReduce1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
cb71c41fabac6a5ef20c9f02bd912331
  alphaReduce_go ::
    Math.Term.Term
    -> [Math.Term.Term] -> GHC.Types.Int -> Math.Term.Term
  {- Arity: 3, Strictness: <S,U><S,1*U><L,U(U)> -}
aa844e3578cba2614f4a532e177ff3b5
  anyCoprod :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.anyCoprod1 Math.Term.U) -}
680a1bfe5dd93ea52f9bc822c251ade4
  anyCoprod1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.anyCoprod2 Math.Term.U) -}
6e72ca1c86c0a9fdcc9bb96dfd81b04a
  anyCoprod2 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Coprod) -}
90f0190aab2a360376fd60e3e0db0866
  anyInhabOf :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Unfolding: (Math.Term.Ap Math.Term.anyInhabOf1) -}
8db405c994e9a7a9e37bc3ae1b8624d6
  anyInhabOf1 :: Math.Term.Term
  {- Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term..:1 Math.Term.wildcard) -}
d2a3bca0789c8c4f90d221b9253b42cb
  applyDefs :: Math.Term.Context -> Math.Term.Context
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Context) ->
                 case w of ww { Math.Term.Ctx ww1 ww2 ->
                 case Math.Term.$wapplyDefs ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 Math.Term.Ctx ww4 ww5 } }) -}
da917cc64c447d1dfb5ea137e8621733
  applyDefs1 :: Math.Term.Context
  {- Strictness: x -}
5a645cc5c862a820a23e8a8e370f4f16
  applyMatches ::
    Math.Term.Term
    -> Math.Term.Context -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <L,U><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (t :: Math.Term.Term) (ds :: Math.Term.Context) ->
                 case ds of wild2 { Math.Term.Ctx ts intree ->
                 Math.Term.applyMatches_go
                   (Data.Set.Internal.Tip @ Math.Term.Term)
                   t
                   intree }) -}
8334e05ebcabcda2dbbe209a6f6ac605
  applyMatches_go ::
    Data.Set.Internal.Set Math.Term.Term
    -> Math.Term.Term
    -> Math.Term.InductionTree
    -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 3, Strictness: <S,U><L,U><S,1*U> -}
892a1918a553475b82ac7d015950d86b
  applyMorphs :: Math.Term.Context -> Math.Term.Context
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,U)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Context) ->
                 case w of ww { Math.Term.Ctx ww1 ww2 ->
                 case Math.Term.$wapplyMorphs ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 Math.Term.Ctx ww4 ww5 } }) -}
330660ffbe19e459bf023bb41d73a48c
  applyMorphs1 :: Math.Term.Context
  {- Strictness: x -}
fa7e05f2f496b9e601804f75cb61e07b
  assocLaw0 :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.assocLaw4
                   Math.Term.assocLaw2) -}
b6d6b3c70c7b83f72eda7578b35899be
  assocLaw1 :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.assocLaw8
                   Math.Term.assocLaw6) -}
3ce9156b11f03abd491e6f2592c48795
  assocLaw2 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Math.Term.Term
                        Math.Term.assocLaw3
                   Math.Term.Ap ds c
                   -> case ds of wild3 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Math.Term.Term
                             Math.Term.assocLaw3
                        Math.Term.Ap a b -> Math.Term.Ap a (Math.Term.Ap b c) } }) -}
30f9de76e9e2ad66f48446f9b9f1f1e6
  assocLaw3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Math\\Term.hs:578:39-72|lambda"#) -}
04d0bf897bb48b05ac516fbbb2920188
  assocLaw4 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.assocLaw5 Math.Term.U) -}
e0cf855f830d9a0bd3a67a987704b753
  assocLaw5 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.U Math.Term.U) -}
c309c984de0beccf1d1ce9a52098079d
  assocLaw6 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ Math.Term.Term
                        Math.Term.assocLaw7
                   Math.Term.Ap a ds
                   -> case ds of wild3 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ Math.Term.Term
                             Math.Term.assocLaw7
                        Math.Term.Ap b c -> Math.Term.Ap (Math.Term.Ap a b) c } }) -}
85e207459ad63a6a9c7ccdf201954e56
  assocLaw7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Math\\Term.hs:581:39-72|lambda"#) -}
f7420d4ef1c53e53327597dc76aa857b
  assocLaw8 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.U Math.Term.assocLaw5) -}
94b8d47855609bffd7eb165a947f707d
  beta :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Math.Term.Term) ->
                 case ds of wild2 {
                   DEFAULT -> Math.Term.beta1
                   Math.Term.Ap ds1 n
                   -> case ds1 of wild3 {
                        DEFAULT -> Math.Term.beta1
                        Math.Term.Lambda x m
                        -> case Data.Set.Internal.disjoint
                                  @ Math.Term.Term
                                  Math.Term.$fOrdTerm
                                  (Math.Term.freeVars n)
                                  (Math.Term.boundVars m) of wild4 {
                             GHC.Types.False -> wild2
                             GHC.Types.True
                             -> Math.Term.substitution (Math.Term.X x) m n } } }) -}
a049993c3ddd794f7ceb7169b638eea3
  beta1 :: Math.Term.Term
  {- Strictness: x -}
f19d3c7a19f98efb144077ecfe64958f
  binary ::
    Math.Term.PrimConst
    -> Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m4,
     Unfolding: InlineRule (3, True, False)
                (\ (p :: Math.Term.PrimConst)
                   (x :: Math.Term.Term)
                   (eta :: Math.Term.Term) ->
                 Math.Term.Ap (Math.Term.Ap (Math.Term.Prim p) x) eta) -}
909e7f5ab1cee5155865cc59e3378519
  bind :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: Math.Term.Term) (expr :: Math.Term.Term) ->
                 case ds of wild2 {
                   DEFAULT
                   -> case Data.Set.Internal.disjoint
                             @ Math.Term.Term
                             Math.Term.$fOrdTerm
                             (Math.Term.boundVars wild2)
                             (Math.Term.freeVars expr) of wild3 {
                        GHC.Types.False -> expr
                        GHC.Types.True
                        -> Math.Term.Ap (Math.Term.Ap Math.Term.bind1 wild2) expr }
                   Math.Term.X x
                   -> case Math.Term.$smember_go3
                             wild2
                             (Math.Term.freeVars expr) of wild3 {
                        GHC.Types.False
                        -> case Math.Term.$smember_go3
                                  wild2
                                  (Math.Term.boundVars expr) of wild4 {
                             GHC.Types.False -> Math.Term.Lambda x expr GHC.Types.True -> expr }
                        GHC.Types.True -> Math.Term.Lambda x expr } }) -}
a55b245f16fe88ecf0d8f96162178770
  bind1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Pi) -}
cb71c41fabac6a5ef20c9f02bd912331
  boundVars :: Math.Term.Term -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U> -}
6e18477164ee58eff1921847a5db0b1a
  coprod :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (eta :: Math.Term.Term) ->
                 Math.Term.Ap (Math.Term.Ap Math.Term.anyCoprod2 x) eta) -}
9e3d920c982efb843b4751958252484d
  coprodType :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (Math.Term.Def
                   Math.Term.anyCoprod
                   Math.Term.coprodType1) -}
16d32562f3ffc7fff9a31b03386d7fb7
  coprodType1 :: [Math.Term.Term]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.coprodType5
                   Math.Term.coprodType2) -}
61f60972fec413eef15b6d00fc7f7419
  coprodType2 :: [Math.Term.Term]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.coprodType3
                   (GHC.Types.[] @ Math.Term.Term)) -}
ce195c63e7e236e760fdbb39c0514626
  coprodType3 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.coprodType4 Math.Term.U) -}
da8044d4a2b525b7728dafa15a14f768
  coprodType4 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Inr) -}
e0aa287b31f172e997818497e9e3f93b
  coprodType5 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.coprodType6 Math.Term.U) -}
3254fcab3d3a19e5e3bc01ea2bf1de5f
  coprodType6 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Inl) -}
6dc9f51eb96c2dd47664da30747d9034
  ctx0 :: Math.Term.Context
  {- Unfolding: (case Math.Term.$wnewTypes
                        (Data.Set.Internal.Tip @ Math.Term.Term)
                        Math.Term.emptyMT
                        Math.Term.ctx2 of ww { (#,#) ww1 ww2 ->
                 Math.Term.Ctx ww1 ww2 }) -}
1fbcf8e2936f9519fe3fce438c21afb9
  ctx1 :: Math.Term.Context
  {- Unfolding: (case Math.Term.ctx0 of wild2 { Math.Term.Ctx ms it1 ->
                 Math.Term.Ctx
                   (Math.Term.$fMonoidContext_$sunion
                      ms
                      (Data.Set.Internal.Tip @ Math.Term.Term))
                   (Math.Term.$fMonoidContext_$c<>1 it1 Math.Term.typeTheory) }) -}
2dbc6fd88670df0c07e8d4108a4fa940
  ctx2 :: [Math.Term.Term]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.zero
                   Math.Term.ctx3) -}
be5a1c97f2a0c9bc62b516e690428253
  ctx3 :: [Math.Term.Term]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.one
                   Math.Term.ctx4) -}
79543d156950ad29a6aaca5ce05d0960
  ctx4 :: [Math.Term.Term]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.two
                   Math.Term.ctx5) -}
50dd645db84a98966941a1375f68b51f
  ctx5 :: [Math.Term.Term]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.nat
                   Math.Term.ctx6) -}
a78d16a884975018b4a087957ebd083f
  ctx6 :: [Math.Term.Term]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.piType
                   Math.Term.ctx7) -}
479b4d7194538ecc2fcd80ad410a8bd0
  ctx7 :: [Math.Term.Term]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.sigmaType
                   Math.Term.ctx8) -}
bb126affe128a53c06dcaac89e373858
  ctx8 :: [Math.Term.Term]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.pairType
                   Math.Term.ctx9) -}
580351fdc2cf7ff3c052cb8c2c69acf6
  ctx9 :: [Math.Term.Term]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.coprodType
                   (GHC.Types.[] @ Math.Term.Term)) -}
869cdeb95cd6029378befa2ddccb378d
  ctxEmp :: Math.Term.Context
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Math.Term.Ctx
                   (Data.Set.Internal.Tip @ Math.Term.Term)
                   Math.Term.emptyMT) -}
34855e38d395cb8f5fc05a39afb95e6d
  defConst :: GHC.Base.String -> Math.Term.Term
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m5,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Base.String) ->
                 Math.Term.Prim (Math.Term.DefConst s)) -}
87576b16a52477cd5620fb1dc9bdb9af
  depth :: Math.Term.Term -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case Math.Term.$wdepth w of ww { DEFAULT -> GHC.Types.I# ww }) -}
66489a3fc3b360de23608a39c6238b30
  derive :: Math.Term.Context -> Math.Term.Context
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ctx :: Math.Term.Context) ->
                 Math.Term.applyMorphs (Math.Term.applyDefs ctx)) -}
96245e8924a8a0a25d6a45f11feba59a
  emptyMT :: Math.Term.InductionTree
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Math.Term.Node
                   Math.Term.emptyMT1
                   Math.Term.U
                   Math.Term.Null
                   Math.Term.Null) -}
d00e83d07d5eb1c198dffbb27b5b18b2
  emptyMT1 :: [Math.Term.Term -> Math.Term.Term]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Math.Term.Term -> Math.Term.Term)
                   (GHC.Base.id @ Math.Term.Term)
                   (GHC.Types.[] @ (Math.Term.Term -> Math.Term.Term))) -}
79e60ac6577b57c4d5623fde968511c6
  equivdef :: Math.Term.Term -> Math.Term.Term -> Math.Term.Inductor
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (input :: Math.Term.Term) (t :: Math.Term.Term) ->
                 Math.Term.Inductor input (\ (ds :: Math.Term.Term) -> t)) -}
7b183949cba2fe329f67c6fd83e91dea
  equivs ::
    Math.Term.Context
    -> Math.Term.Term -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ctx :: Math.Term.Context) (t :: Math.Term.Term) ->
                 Math.Term.getRelated Math.Term.EQUIV t ctx) -}
03c7a11f3571db86421143fc4a51d943
  false2 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.coprodType6 Math.Term.zero) -}
012e8faad63cef91228fa9007305500d
  freeVars :: Math.Term.Term -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U> -}
74c94ff16ced442f883d5a382fa68856
  funcComp :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Math.Term.Term) ->
                 case ds of wild2 {
                   DEFAULT -> Math.Term.funcComp1
                   Math.Term.Ap ds1 c
                   -> case ds1 of wild3 {
                        DEFAULT -> Math.Term.funcComp1
                        Math.Term.Ap ds2 b
                        -> case ds2 of wild4 {
                             DEFAULT -> Math.Term.funcComp1
                             Math.Term.Ap ds3 a
                             -> case ds3 of wild5 {
                                  DEFAULT -> Math.Term.funcComp1
                                  Math.Term.Prim ds4
                                  -> case ds4 of wild6 {
                                       DEFAULT -> Math.Term.funcComp1
                                       Math.Term.Func
                                       -> case Math.Term.$fEqInductor_$c==1 a c of wild7 {
                                            GHC.Types.False
                                            -> Math.Term.Ap
                                                 (Math.Term.Ap (Math.Term.Ap Math.Term.-->1 a) b)
                                                 c
                                            GHC.Types.True -> b } } } } } }) -}
8db1c5c16461eb9fec6d19b80581a96f
  funcComp1 :: Math.Term.Term
  {- Strictness: x -}
b6470e2ab4e72807098612e4e3a96cf2
  funcElim :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.funcElim1
                   Math.Term.funcComp) -}
dc4b230c172a7f4ca7f4bf3de2def2b4
  funcElim1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.funcType Math.Term.U) -}
c836ab679df99a19ee48d3ea04c7135a
  funcToInd :: Math.Term.Term -> Math.Term.Inductor
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT -> Math.Term.funcToInd1
                   Math.Term.Ap ds g
                   -> case ds of wild3 {
                        DEFAULT -> Math.Term.funcToInd1
                        Math.Term.Ap ds1 m
                        -> case ds1 of wild4 {
                             DEFAULT -> Math.Term.funcToInd1
                             Math.Term.Prim ds2
                             -> case ds2 of wild5 {
                                  DEFAULT -> Math.Term.funcToInd1
                                  Math.Term.Func
                                  -> Math.Term.Inductor
                                       m
                                       (\ (ds3 :: Math.Term.Term) -> g) } } } }) -}
4a6c04ca4246f49101d86758d03f078c
  funcToInd1 :: Math.Term.Inductor
  {- Strictness: x -}
9f76bf948b3f9447143570084bd9bf38
  funcType :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.funcType1 Math.Term.U) -}
a6574489278ad1dbd44a4bf95c65922c
  funcType1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.-->1 Math.Term.U) -}
577ccb8b46dcf297ccc799e4a1b65cf5
  getDefSubs :: Math.Term.Term -> [Math.Term.Term]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Math.Term.Term) ->
                 case ds of wild2 {
                   DEFAULT -> Math.Term.getDefSubs1 Math.Term.Def f cs -> cs }) -}
100e2ccba83b3febb2671c970528b312
  getDefSubs1 :: [Math.Term.Term]
  {- Strictness: x -}
8950bf788016f95b1586559f629f926b
  getRelated ::
    Math.Term.TypeRel
    -> Math.Term.Term
    -> Math.Term.Context
    -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 3, Strictness: <L,U><L,U><S(LS),1*U(A,1*U)>, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Math.Term.TypeRel)
                   (w1 :: Math.Term.Term)
                   (w2 :: Math.Term.Context) ->
                 case w2 of ww { Math.Term.Ctx ww1 ww2 ->
                 Math.Term.$wgetRelated w w1 ww2 }) -}
df78ee78517b16a378837a17b284512d
  getRelations ::
    Math.Term.Term
    -> Math.Term.Context
    -> Data.Set.Internal.Set (Math.Term.Term, Math.Term.TypeRel)
  {- Arity: 2, Strictness: <L,U><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (t :: Math.Term.Term) (ds :: Math.Term.Context) ->
                 case ds of wild2 { Math.Term.Ctx ts intree ->
                 Math.Term.getRelations_go
                   (Data.Set.Internal.Tip @ (Math.Term.Term, Math.Term.TypeRel))
                   t
                   intree }) -}
df502b72a85dbc55b7463c51cd64c8db
  getRelations_go ::
    Data.Set.Internal.Set (Math.Term.Term, Math.Term.TypeRel)
    -> Math.Term.Term
    -> Math.Term.InductionTree
    -> Data.Set.Internal.Set (Math.Term.Term, Math.Term.TypeRel)
  {- Arity: 3, Strictness: <S,U><L,U><S,1*U> -}
b07b7739821f15c47f5a1564bbbd8097
  ident :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (eta :: Math.Term.Term) ->
                 Math.Term.Ap (Math.Term.Ap Math.Term.reflElim2 x) eta) -}
cd4cdd8b155ec951a7e02cdb2f340259
  identityFunctorLaw1 :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.identityFunctorLaw11
                   Math.Term.identityFunctorLaw9) -}
13c5577babd583f9baa3b96479e930ff
  identityFunctorLaw10 :: Math.Term.Term
  {- Strictness: x -}
07cfc4876ebb746eed94160cb7dee145
  identityFunctorLaw11 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap
                   Math.Term.U
                   Math.Term.identityFunctorLaw7) -}
92ad623ba11f3a2d3d8f815155b6a3ae
  identityFunctorLaw2 :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.identityFunctorLaw6
                   Math.Term.identityFunctorLaw4) -}
c3830a4a8d3a4e4353f8fafc90b5cf65
  identityFunctorLaw4 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case Math.Term.$widentityFunctorLaw2 w of ww { (#,#) ww1 ww2 ->
                 Math.Term.Ap ww1 ww2 }) -}
42b22cd93e4f8c68dbd561622371ef4c
  identityFunctorLaw5 :: Math.Term.Term
  {- Strictness: x -}
329a509f5f052997cdbedfcb80ef7780
  identityFunctorLaw6 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap
                   Math.Term.identityFunctorLaw7
                   Math.Term.U) -}
1f8b5fe9254e729f1abd0289d32c6091
  identityFunctorLaw7 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap
                   Math.Term.identityFunctorLaw8
                   Math.Term.U) -}
229aa33a1bb74fdc14374ff08a2c29bb
  identityFunctorLaw8 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.reflElim2 Math.Term.U) -}
1aef78cebfdb9ab976596564489ff745
  identityFunctorLaw9 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case Math.Term.$widentityFunctorLaw1 w of ww { (#,#) ww1 ww2 ->
                 Math.Term.Ap ww1 ww2 }) -}
4471137610b6a6253b9077099b6ded71
  indMorph :: Math.Term.Inductor -> Math.Term.Term -> Math.Term.Term
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Math.Term.Inductor) ->
                 case ds of wild2 { Math.Term.Inductor m f -> f }) -}
e447f108c112bd3f191ab49f8fc2286a
  indPattern :: Math.Term.Inductor -> Math.Term.Term
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Math.Term.Inductor) ->
                 case ds of wild2 { Math.Term.Inductor m f -> m }) -}
fe577c8381b927379cbe197869d5b576
  indToFunc :: Math.Term.Inductor -> Math.Term.Term
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*C1(U))>m4,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Math.Term.Inductor) ->
                 case ds of wild2 { Math.Term.Inductor m f ->
                 Math.Term.Ap (Math.Term.Ap Math.Term.-->1 m) (f m) }) -}
5fdc0889ecbccee6f829ccc6bdf21cd2
  indToTree ::
    Math.Term.InductionTree -> Data.Tree.Tree Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (tree :: Math.Term.InductionTree) ->
                 GHC.List.$w!!
                   @ (Data.Tree.Tree Math.Term.Term)
                   (Math.Term.$fShowContext_go tree)
                   0#) -}
20658b4252557359e22448b91e2f16d5
  indX :: GHC.Types.Int -> Math.Term.Term
  {- Arity: 1, Strictness: <L,1*U(U)>m2, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 Math.Term.X
                   (GHC.Base.augment
                      @ GHC.Types.Char
                      (\ @ b
                         (c :: GHC.Types.Char -> b -> b)[OneShot]
                         (n :: b)[OneShot] ->
                       GHC.Base.foldr
                         @ GHC.Types.Char
                         @ b
                         c
                         n
                         (GHC.CString.unpackCStringUtf8# "\\240\\157\\145\\165"#))
                      (case w of ww { GHC.Types.I# ww1 ->
                       Math.Term.$wsubscript ww1 }))) -}
0fbd56cd1ac245a4174fe2fa30c074b0
  indX1 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Math.Term.indX29
                   Math.Term.indX2) -}
0aab25ad3acad8d77b000d161fffdb0c
  indX10 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Math.Term.indX11
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
dce72c08cfa2676394055e4e39545b6a
  indX11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Math.Term.indX12) -}
0623d33270dbcb5f77cd9a98ad12b2df
  indX12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\130\\137"#) -}
3ce6789c09dc47fe89db937929f7e152
  indX13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Math.Term.indX14) -}
0ee68fb642b74ff8ae670a8f533e696a
  indX14 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\130\\136"#) -}
6cff3d8e009db373d4920bb49746205a
  indX15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Math.Term.indX16) -}
e42bf158a0c9941571cc089b9ea84adc
  indX16 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\130\\135"#) -}
6e1d1dc9f54136425e3e21bcf7b7fec4
  indX17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Math.Term.indX18) -}
3da24d83b8308fd8858a45232244a858
  indX18 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\130\\134"#) -}
92de036d97a0eae18a62d8c2656a017a
  indX19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Math.Term.indX20) -}
a94c2e3e0123576f67351f12e9f40dbc
  indX2 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Math.Term.indX27
                   Math.Term.indX3) -}
584903903715c72345cdd074eda80187
  indX20 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\130\\133"#) -}
ceb9f8e9a9652ed88a1d2d080556a11b
  indX21 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Math.Term.indX22) -}
0fec007cc4309f069fe97e9de15e355d
  indX22 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\130\\132"#) -}
5c81ae0ade3422a8aeee61390eb06525
  indX23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Math.Term.indX24) -}
1610d1cdad709011ae04568f049f4502
  indX24 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\130\\131"#) -}
986b929fde6f3bc44b41345014fe0348
  indX25 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Math.Term.indX26) -}
cfd0c0487c3c211fd1c8d2e541065c6e
  indX26 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\130\\130"#) -}
ab23408ea046e80adda95afd736cdf44
  indX27 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Math.Term.indX28) -}
72375f9e923467cf9a8e971a3bda6f75
  indX28 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\130\\129"#) -}
de54dc9859e2a1cac888fe6c337e1380
  indX29 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Math.Term.indX30) -}
8a40a7a3210851eec7a8cb7e65be10b3
  indX3 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Math.Term.indX25
                   Math.Term.indX4) -}
c78812aa07b4d1c20c15971b3241cb6d
  indX30 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\130\\128"#) -}
1b478e517432c933954a730303de109a
  indX4 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Math.Term.indX23
                   Math.Term.indX5) -}
4c09be66353746e8d766b47a2da399b0
  indX5 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Math.Term.indX21
                   Math.Term.indX6) -}
31cca38df1fae7ba8a1307b79208d104
  indX6 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Math.Term.indX19
                   Math.Term.indX7) -}
a6dc9c2c45bcb0c54fc2b3d0ae9689bf
  indX7 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Math.Term.indX17
                   Math.Term.indX8) -}
d224af0f0123406c5db395218570d52b
  indX8 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Math.Term.indX15
                   Math.Term.indX9) -}
7a69578f942f6d6ab99ac6540f005d3b
  indX9 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Math.Term.indX13
                   Math.Term.indX10) -}
3fc13d6ee764d861ef380095d8cd499f
  indX_go :: [GHC.Types.Int] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
9b8ea70a30016ed9dc77ecc4e01b5d43
  induct ::
    Math.Term.Inductor
    -> Math.Term.Term -> GHC.Maybe.Maybe Math.Term.Term
  {- Arity: 2, Strictness: <S(SL),1*U(U,1*C1(U))><S,U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Math.Term.Inductor) (w1 :: Math.Term.Term) ->
                 case w of ww { Math.Term.Inductor ww1 ww2 ->
                 Math.Term.$winduct ww1 ww2 w1 }) -}
5c2b7ee59086006ccc34048dec13d978
  inductionTree :: [Math.Term.Inductor] -> Math.Term.InductionTree
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: [Math.Term.Inductor]) ->
                 case ds of wild2 {
                   [] -> Math.Term.emptyMT
                   : ipv ipv1 -> Math.Term.insertAllMT Math.Term.emptyMT wild2 }) -}
35d0c13569a3bd1be91af20f35c0c745
  inductors :: Math.Term.InductionTree -> [Math.Term.Inductor]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Math.Term.$fMonoidContext_go1
                   (GHC.Types.[] @ Math.Term.Inductor)) -}
99446f3d243e9e30a9be45b4d58ecd20
  inhabOne :: Math.Term.Term
  {- Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.inhabOne1) -}
0e9dc1e2daa638e793f8dbe901d7583b
  inhabOne1 :: Math.Term.PrimConst
  {- Strictness: m1,
     Unfolding: (Math.Term.DefConst Math.Term.inhabOne2) -}
19aa634d6063e7b1ba6b6631a43c63ab
  inhabOne2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8#
                   Math.Term.inhabOne3) -}
c5fa8bb7233506c34e6ef0699e8112ed
  inhabOne3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\226\\139\\134"#) -}
f8cef641a2a46c84ee301ac90219c800
  inl :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m4,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: Math.Term.Term) ->
                 Math.Term.Ap Math.Term.coprodType6 eta) -}
7f719ef8bb76bf95cf8e3b95b7ce42e7
  inr :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m4,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: Math.Term.Term) ->
                 Math.Term.Ap Math.Term.coprodType4 eta) -}
06be6b2fc2c6b8bce2d53ad8010980a7
  insertAllMT ::
    Math.Term.InductionTree
    -> [Math.Term.Inductor] -> Math.Term.InductionTree
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
09fce9ccde9f5b72178bfc6bd2967014
  insertMT ::
    Math.Term.InductionTree
    -> Math.Term.Inductor -> Math.Term.InductionTree
  {- Arity: 2, Strictness: <S,1*U><S(SL),1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (tree :: Math.Term.InductionTree) (ind :: Math.Term.Inductor) ->
                 case ind of wild2 { Math.Term.Inductor m f ->
                 Math.Term.insertMT_go tree m f }) -}
8fc3eee5ebf5ffd38de8ecc37b555272
  insertMT_go ::
    Math.Term.InductionTree
    -> Math.Term.Term
    -> (Math.Term.Term -> Math.Term.Term)
    -> Math.Term.InductionTree
  {- Arity: 3, Strictness: <S,1*U><S,U><L,U> -}
b6ea368ec884140204c1ac4ee4f9b454
  intro :: Math.Term.Context -> Math.Term.Term -> Math.Term.Context
  {- Arity: 2, Strictness: <S,1*U(1*U,U)><S,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Math.Term.Context) (t :: Math.Term.Term) ->
                 case ds of wild2 { Math.Term.Ctx s it ->
                 Math.Term.newType
                   t
                   (Math.Term.Ctx (Math.Term.$sinsert_$sgo1 t t s) it) }) -}
e2392361f6de84315f0da064e213eb95
  introRules ::
    [Math.Term.Inductor] -> Math.Term.Context -> Math.Term.Context
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: [Math.Term.Inductor]) (ctx :: Math.Term.Context) ->
                 case ds of wild2 {
                   [] -> ctx
                   : ipv ipv1
                   -> case ctx of wild3 { Math.Term.Ctx set tree ->
                      Math.Term.Ctx set (Math.Term.insertAllMT tree wild2) } }) -}
d7f49109425ee82ecd0e7a047e8d7633
  intros ::
    Math.Term.Context -> [Math.Term.Term] -> Math.Term.Context
  {- Arity: 2, Strictness: <S,1*U(1*U,U)><S,1*U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Math.Term.Context) (w1 :: [Math.Term.Term]) ->
                 case w of ww { Math.Term.Ctx ww1 ww2 ->
                 case Math.Term.$wintros ww1 ww2 w1 of ww3 { (#,#) ww4 ww5 ->
                 Math.Term.Ctx ww4 ww5 } }) -}
89b6c8fb03b61d7d3050e69f4c615ee4
  isMemberOf ::
    Math.Term.Term -> Math.Term.InductionTree -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
e275573b58bc7b62cf46b86900d4bad9
  lambdaInductor :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.lambdaInductor1
                   Math.Term.beta) -}
3942f631671537ff270b06c1cc4b059b
  lambdaInductor1 :: Math.Term.Term
  {- Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.lambdaType Math.Term.U) -}
091b092edd648f8e2cc4363d8d1d5481
  lambdaType :: Math.Term.Term
  {- Strictness: m3,
     Unfolding: (Math.Term.Lambda Math.Term.wild Math.Term.U) -}
1403ba88670e44647c11360764ef5710
  metaType :: Math.Term.Term -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
b68070e114eeeec1ee861ffa61cea4cc
  nat :: Math.Term.Term
  {- Strictness: m6,
     Unfolding: (Math.Term.Def Math.Term.nat3 Math.Term.nat1) -}
0b73e67eb8a93f8466718fc4e5122444
  nat1 :: [Math.Term.Term]
  {- Unfolding: (Math.Term.nat2
                   @ [Math.Term.Term]
                   (GHC.Types.: @ Math.Term.Term)
                   (GHC.Types.[] @ Math.Term.Term)) -}
281fa3224688804c2e3604998d9be33c
  nat2 :: (Math.Term.Term -> a -> a) -> a -> a
  {- Arity: 2, Strictness: <C(C(S)),C(C1(U))><L,U> -}
5d978028e4f9b3cc7169a40db953473a
  nat3 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Nat) -}
54a52c9883385b3055d7159720038a4b
  natnum :: GHC.Types.Int -> Math.Term.Term
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 -> Math.Term.$wnatnum ww1 }) -}
6d23433b9ba9808a45f310c28343fd39
  newIdents ::
    Math.Term.Context -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Context) ->
                 case w of ww { Math.Term.Ctx ww1 ww2 ->
                 Math.Term.$wnewIdents ww1 ww2 }) -}
272a1905b8cf85cfbee705303872b3a3
  newType :: Math.Term.Term -> Math.Term.Context -> Math.Term.Context
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U)>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Math.Term.Term) (w1 :: Math.Term.Context) ->
                 case w1 of ww { Math.Term.Ctx ww1 ww2 ->
                 case Math.Term.$wnewType w ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 Math.Term.Ctx ww4 ww5 } }) -}
cd57805a75492bd7e536089302c77b67
  newTypes ::
    Math.Term.Context -> [Math.Term.Term] -> Math.Term.Context
  {- Arity: 2, Strictness: <S,1*U(U,U)><S,1*U>m, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Math.Term.Context) (w1 :: [Math.Term.Term]) ->
                 case w of ww { Math.Term.Ctx ww1 ww2 ->
                 case Math.Term.$wnewTypes ww1 ww2 w1 of ww3 { (#,#) ww4 ww5 ->
                 Math.Term.Ctx ww4 ww5 } }) -}
39c6715238ad3444875c923d7c5553d0
  numnat :: Math.Term.Term -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case Math.Term.$wnumnat w of ww { DEFAULT -> GHC.Types.I# ww }) -}
9e78c5653c46429670782412b4403e6a
  one :: Math.Term.Term
  {- Strictness: m6,
     Unfolding: (Math.Term.Def Math.Term.one4 Math.Term.one1) -}
875dbf018cf77789b114c24c8f51a810
  one1 :: [Math.Term.Term]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.inhabOne
                   Math.Term.one2) -}
10012200fffcb273889b8ef893da6aff
  one2 :: [Math.Term.Term]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.one3
                   (GHC.Types.[] @ Math.Term.Term)) -}
0be26ccdc3d622997959fc17b49c79bd
  one3 :: Math.Term.Term
  {- Strictness: m3,
     Unfolding: (Math.Term.Lambda Math.Term.wild Math.Term.wildcard) -}
b820bbd145933598bd6852919c863205
  one4 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.One) -}
8c94eb86c40171c2ad6d8e0f172feb02
  oneInductor :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.oneInductor3
                   Math.Term.oneInductor1) -}
ce24897d2dec01a26d288ebbe6f6b0e6
  oneInductor1 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Math.Term.Term) ->
                 case ds of wild2 {
                   DEFAULT -> Math.Term.oneInductor2
                   Math.Term.Ap ds1 c
                   -> case ds1 of wild3 {
                        DEFAULT -> Math.Term.oneInductor2
                        Math.Term.Ap ds2 ds3
                        -> case ds2 of wild4 {
                             DEFAULT -> Math.Term.oneInductor2
                             Math.Term.Prim ds4
                             -> case ds4 of wild5 {
                                  DEFAULT -> Math.Term.oneInductor2
                                  Math.Term.Pi
                                  -> case ds3 of wild6 {
                                       DEFAULT -> Math.Term.oneInductor2
                                       Math.Term.Prim ds5
                                       -> case ds5 of wild7 {
                                            DEFAULT -> Math.Term.oneInductor2
                                            Math.Term.DefConst ds6
                                            -> case ds6 of wild8 {
                                                 [] -> Math.Term.oneInductor2
                                                 : ds7 ds8
                                                 -> case ds7 of wild9 { GHC.Types.C# ds9 ->
                                                    case ds9 of ds10 {
                                                      DEFAULT -> Math.Term.oneInductor2
                                                      '\8902'#
                                                      -> case ds8 of wild10 {
                                                           [] -> c
                                                           : ipv ipv1
                                                           -> Math.Term.oneInductor2 } } } } } } } } } }) -}
3ae0b3284d42e5e940d8df6b44f42c64
  oneInductor2 :: Math.Term.Term
  {- Strictness: x -}
f61c37b8b997a0169b25a95975c2c369
  oneInductor3 :: Math.Term.Term
  {- Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.oneInductor4 Math.Term.U) -}
76d21f9606cc9bf390f3b4fe5fa9a653
  oneInductor4 :: Math.Term.Term
  {- Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.bind1 Math.Term.inhabOne) -}
fc01b682398ee8e348c2600d9276a46e
  pair :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (eta :: Math.Term.Term) ->
                 Math.Term.Ap (Math.Term.Ap Math.Term.$fMonoidTerm1 x) eta) -}
a185139235351004e9ccf49460fd1f64
  pairType :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.pairType1 Math.Term.U) -}
49dca3a5666b7f2deda023b3ce5f96de
  pairType1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.$fMonoidTerm1 Math.Term.U) -}
dd90f1cf046db9a04b389394cfb6ba4b
  pathInduction ::
    Math.Term.Context
    -> Math.Term.Term -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <S(LS),1*U(A,U)><S,1*U>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Math.Term.Context) (w1 :: Math.Term.Term) ->
                 case w of ww { Math.Term.Ctx ww1 ww2 ->
                 Math.Term.$wpathInduction ww2 w1 }) -}
01cd3feed603be07028d2d6587c45e33
  piCons :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (eta :: Math.Term.Term) ->
                 Math.Term.Ap (Math.Term.Ap Math.Term.bind1 x) eta) -}
0f51e75807703ccb3e446cf987159728
  piCoprodComp :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case Math.Term.$wpiCoprodComp w of ww { (#,#) ww1 ww2 ->
                 Math.Term.Ap ww1 ww2 }) -}
3161ace5cc77c48a58658dd43fa8423d
  piCoprodComp1 :: Math.Term.Term
  {- Strictness: x -}
36be7128a495bb58a936376c4a122a71
  piInductor1 :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.lambdaType
                   Math.Term.piInductor15) -}
f6b31c0293a6d20c2070b094389c6fc5
  piInductor10 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.bind1 Math.Term.sigmaType) -}
bf74ceaf60893dd119d5955a26fbcdd1
  piInductor11 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m3, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT -> Math.Term.piInductor12
                   Math.Term.Ap ds b
                   -> case ds of wild3 {
                        DEFAULT -> Math.Term.piInductor12
                        Math.Term.Ap ds1 ds2
                        -> case ds1 of wild4 {
                             DEFAULT -> Math.Term.piInductor12
                             Math.Term.Prim ds3
                             -> case ds3 of wild5 {
                                  DEFAULT -> Math.Term.piInductor12
                                  Math.Term.Pi
                                  -> case ds2 of wild6 {
                                       DEFAULT -> Math.Term.piInductor12
                                       Math.Term.X a -> Math.Term.Lambda a b } } } } }) -}
a967e24688b2428e38b074f119095321
  piInductor12 :: Math.Term.Term
  {- Strictness: x -}
1679710d6b3e7877f7cad8e85af3dd9f
  piInductor13 :: Math.Term.Term
  {- Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.piInductor14 Math.Term.U) -}
9ff03b5374af19d6e993af98947533ee
  piInductor14 :: Math.Term.Term
  {- Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.bind1 Math.Term.wildcard) -}
ba8d472c2aeafac592e840b307ab2b89
  piInductor15 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Math.Term.Term) ->
                 case ds of wild2 {
                   DEFAULT -> Math.Term.piInductor16
                   Math.Term.Lambda a b
                   -> Math.Term.Ap
                        (Math.Term.Ap Math.Term.bind1 (Math.Term.X a))
                        b }) -}
ba7f59e2de5c5df56b8f7be011f1e681
  piInductor16 :: Math.Term.Term
  {- Strictness: x -}
6e92bab34ac22801cf32284873144baa
  piInductor2 :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.piInductor13
                   Math.Term.piInductor11) -}
2d722af44b2884099695795db8a8472f
  piInductor3 :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.piInductor9
                   Math.Term.piSigmaComp) -}
22739690a2f31897fcb4cefd8e7eb3ae
  piInductor4 :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.piInductor7
                   Math.Term.piCoprodComp) -}
896b1350e9479ebb9a84b141af6168fb
  piInductor7 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap
                   Math.Term.piInductor8
                   Math.Term.pairType) -}
730a61ad73acb4d39822c8f6cdef39db
  piInductor8 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.bind1 Math.Term.anyCoprod) -}
d09702eba39130d460f6dabe9a69fc57
  piInductor9 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.piInductor10 Math.Term.U) -}
2c4dcc9b7cc380dffe1e383005467cfd
  piSigmaComp :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case Math.Term.$wpiSigmaComp w of ww { (#,#) ww1 ww2 ->
                 Math.Term.Ap ww1 ww2 }) -}
fcfed67a7042dad8e64e22553cb1a15c
  piSigmaComp1 :: Math.Term.Term
  {- Strictness: x -}
45a6bd2e3072fa4062fab7f6409f12c8
  piType :: Math.Term.Term
  {- Strictness: m6,
     Unfolding: (Math.Term.Def Math.Term.piType3 Math.Term.piType1) -}
d7a5bf47db64ca53091295dcc568866a
  piType1 :: [Math.Term.Term]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.lambdaType
                   Math.Term.piType2) -}
0984c5628446eda6d17e881228948e44
  piType2 :: [Math.Term.Term]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.funcType
                   (GHC.Types.[] @ Math.Term.Term)) -}
1dfe560a15d0c1415a5a606678207997
  piType3 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.piType4 Math.Term.U) -}
1880d295e5ea1d556f57c1c303d3618a
  piType4 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.bind1 Math.Term.U) -}
8bbab8b8129c8be874179eae49a998f3
  prjLInd :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.prjMatchL
                   Math.Term.prjMatchLComp) -}
d24a24888ce199c47c76071d210eb2f6
  prjMatchL :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap
                   Math.Term.prjMatchL1
                   Math.Term.pairType) -}
959699c6a55f882bb7e6956e4305ce85
  prjMatchL1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Prjl) -}
f93e485396b1fbcb2a102c5463de17ec
  prjMatchLComp :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Math.Term.Term) ->
                 case ds of wild2 {
                   DEFAULT -> Math.Term.prjMatchLComp1
                   Math.Term.Ap ds1 ds2
                   -> case ds1 of wild3 {
                        DEFAULT -> Math.Term.prjMatchLComp1
                        Math.Term.Prim ds3
                        -> case ds3 of wild4 {
                             DEFAULT -> Math.Term.prjMatchLComp1
                             Math.Term.Prjl
                             -> case ds2 of wild5 {
                                  DEFAULT -> Math.Term.prjMatchLComp1
                                  Math.Term.Ap ds4 b
                                  -> case ds4 of wild6 {
                                       DEFAULT -> Math.Term.prjMatchLComp1
                                       Math.Term.Ap ds5 a
                                       -> case ds5 of wild7 {
                                            DEFAULT -> Math.Term.prjMatchLComp1
                                            Math.Term.Prim ds6
                                            -> case ds6 of wild8 {
                                                 DEFAULT -> Math.Term.prjMatchLComp1
                                                 Math.Term.Pair -> a } } } } } } }) -}
ce45ef1dfd72424d9453adfb8049a52e
  prjMatchLComp1 :: Math.Term.Term
  {- Strictness: x -}
5171aaf22efef1475fb611e4b30b2092
  prjMatchR :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap
                   Math.Term.prjMatchR1
                   Math.Term.pairType) -}
8bf93a5ae14f300d7f20b747809faeee
  prjMatchR1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Prjr) -}
53bc831cf2ebcbd31b11e8645ef060e2
  prjMatchRComp :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Math.Term.Term) ->
                 case ds of wild2 {
                   DEFAULT -> Math.Term.prjMatchRComp1
                   Math.Term.Ap ds1 ds2
                   -> case ds1 of wild3 {
                        DEFAULT -> Math.Term.prjMatchRComp1
                        Math.Term.Prim ds3
                        -> case ds3 of wild4 {
                             DEFAULT -> Math.Term.prjMatchRComp1
                             Math.Term.Prjr
                             -> case ds2 of wild5 {
                                  DEFAULT -> Math.Term.prjMatchRComp1
                                  Math.Term.Ap ds4 b
                                  -> case ds4 of wild6 {
                                       DEFAULT -> Math.Term.prjMatchRComp1
                                       Math.Term.Ap ds5 a
                                       -> case ds5 of wild7 {
                                            DEFAULT -> Math.Term.prjMatchRComp1
                                            Math.Term.Prim ds6
                                            -> case ds6 of wild8 {
                                                 DEFAULT -> Math.Term.prjMatchRComp1
                                                 Math.Term.Pair -> b } } } } } } }) -}
32f22f64d018bc1b6f275b992e2c6205
  prjMatchRComp1 :: Math.Term.Term
  {- Strictness: x -}
8c5717dc73a150cefce1eb34a7476961
  prjRInd :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.prjMatchR
                   Math.Term.prjMatchRComp) -}
408677dc184d6563f50dd3fb621b19ab
  prjl :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Math.Term.Ap Math.Term.prjMatchL1) -}
cf4b1f10f69c902bc5d5c3b6b00c469c
  prjr :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Math.Term.Ap Math.Term.prjMatchR1) -}
58cc01357ef83527dfd3a5b513f8e2ae
  processList :: [a -> a] -> a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (fs :: [a -> a]) (a1 :: a) ->
                 letrec {
                   go8 :: [a -> a] -> a -> a <join 2> {- Arity: 2 -}
                   = \ (ds :: [a -> a]) (eta :: a) ->
                     case ds of wild2 { [] -> eta : y ys -> go8 ys (y eta) }
                 } in
                 go8 fs a1) -}
fd6abd1db629e874541fe4cbb8b8e02a
  pureSub ::
    Math.Term.Term
    -> Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 3, Strictness: <S,U><S,U><L,U> -}
62eca44121f00857e3b8e4007e7b86f6
  refl :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m4,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: Math.Term.Term) ->
                 Math.Term.Ap Math.Term.reflElim5 eta) -}
edb37bd49eec95f3c7497abbfcc069a6
  reflElim :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.reflElim4
                   Math.Term.reflElim1) -}
bc562f1beeeb5263d2010a3b672c33fc
  reflElim1 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT -> Math.Term.reflElim3
                   Math.Term.Ap ds x
                   -> case ds of wild3 {
                        DEFAULT -> Math.Term.reflElim3
                        Math.Term.Prim ds1
                        -> case ds1 of wild4 {
                             DEFAULT -> Math.Term.reflElim3
                             Math.Term.Refl
                             -> Math.Term.Ap (Math.Term.Ap Math.Term.reflElim2 x) x } } }) -}
7ba24816ef04923f833245d420258172
  reflElim2 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Ident) -}
dd47412cd7450d44c31036c7684a32ee
  reflElim3 :: Math.Term.Term
  {- Strictness: x -}
e1f42fb6099429f993a6ddf81b8ee361
  reflElim4 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.reflElim5 Math.Term.U) -}
7732637292568d1355100dc3186b0aee
  reflElim5 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Refl) -}
0e5a723b7a6435e7f12d5e7789b2875d
  reflectLaw :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.identityFunctorLaw7
                   Math.Term.reflectLaw1) -}
75a9f27a40ff9c27b8ffe6b460dac1dc
  reflectLaw1 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case w of wild2 {
                   DEFAULT -> Math.Term.reflectLaw2
                   Math.Term.Ap ds b
                   -> case ds of wild3 {
                        DEFAULT -> Math.Term.reflectLaw2
                        Math.Term.Ap ds1 a
                        -> case ds1 of wild4 {
                             DEFAULT -> Math.Term.reflectLaw2
                             Math.Term.Prim ds2
                             -> case ds2 of wild5 {
                                  DEFAULT -> Math.Term.reflectLaw2
                                  Math.Term.Ident
                                  -> Math.Term.Ap (Math.Term.Ap Math.Term.reflElim2 b) a } } } }) -}
d5594c61de48cf9e2358744d9a2ca974
  reflectLaw2 :: Math.Term.Term
  {- Strictness: x -}
cb71c41fabac6a5ef20c9f02bd912331
  relation :: Math.Term.Term -> Math.Term.Term -> Math.Term.TypeRel
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (a :: Math.Term.Term) (b :: Math.Term.Term) ->
                 case Math.Term.$fEqInductor_$c==1 a b of wild2 {
                   GHC.Types.False
                   -> Math.Term.$fMonoidContext_goRelation
                        (Math.Term.alphaReduce a)
                        (Math.Term.alphaReduce b)
                   GHC.Types.True -> Math.Term.EQUIV }) -}
5211b0a25251f87a35daeca509453539
  setconcat :: GHC.Classes.Ord a => [a] -> [a] -> [a]
  {- Arity: 3,
     Strictness: <L,U(A,C(C1(U)),A,A,A,C(C1(U)),A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd1 :: GHC.Classes.Ord a)
                   (x :: [a])
                   (y :: [a]) ->
                 Data.Set.Internal.$fDataSet_go
                   @ a
                   (GHC.Types.[] @ a)
                   (Data.Set.Internal.union
                      @ a
                      $dOrd1
                      (Data.Set.Internal.fromList @ a $dOrd1 x)
                      (Data.Set.Internal.fromList @ a $dOrd1 y))) -}
31ad0871dcb951130b230889ee836bfa
  setconcat_$ssetconcat ::
    [Math.Term.Term] -> [Math.Term.Term] -> [Math.Term.Term]
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: [Math.Term.Term]) (y :: [Math.Term.Term]) ->
                 Data.Set.Internal.$fDataSet_go
                   @ Math.Term.Term
                   (GHC.Types.[] @ Math.Term.Term)
                   (Math.Term.$fMonoidContext_$sunion
                      (Math.Term.$sfromList x)
                      (Math.Term.$sfromList y))) -}
01e956a51e8526fd343d5274c1ab48cd
  showMatches ::
    Math.Term.Term
    -> Math.Term.Context -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <L,U><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (t :: Math.Term.Term) (ds :: Math.Term.Context) ->
                 case ds of wild2 { Math.Term.Ctx ts intree ->
                 Math.Term.showMatches_go
                   (Data.Set.Internal.Tip @ Math.Term.Term)
                   t
                   intree }) -}
f998f37cf3c8f06c436e16c62ff6607c
  showMatches_go ::
    Data.Set.Internal.Set Math.Term.Term
    -> Math.Term.Term
    -> Math.Term.InductionTree
    -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 3, Strictness: <S,U><L,U><S,1*U> -}
d4bf53c186ad46947ff9851a3f03a4b0
  sigmaComp1 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case Math.Term.$wsigmaComp1 w of ww { (#,#) ww1 ww2 ->
                 Math.Term.Ap ww1 ww2 }) -}
4cc3882034e8c6b538784e938a0eeebe
  sigmaComp2 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <B,1*U>x -}
3dc3280e456ac4564d67a52c732cb1e4
  sigmaCons :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: Math.Term.Term) (eta :: Math.Term.Term) ->
                 Math.Term.Ap (Math.Term.Ap Math.Term.sigmaType4 x) eta) -}
f72f6a6784946f610a433712c6efab50
  sigmaInductor1 :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.sigmaType2
                   Math.Term.sigmaComp1) -}
66d08f458cc9d803187655fa5f2ce173
  sigmaInductor2 :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.sigmaInductor9
                   Math.Term.sigmaInductor7) -}
9692920a41a4ead689c34a5960ac458a
  sigmaInductor3 :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.sigmaInductor6
                   Math.Term.sigmaInductor4) -}
200c4f5a7264669ea01c6ececed78206
  sigmaInductor4 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case Math.Term.$wsigmaInductor3 w of ww { (#,#) ww1 ww2 ->
                 Math.Term.Ap ww1 ww2 }) -}
7e58387aa133673000baa8e2527a6e88
  sigmaInductor5 :: Math.Term.Term
  {- Strictness: x -}
66e000ef35d46f33832d74023a9bbed4
  sigmaInductor6 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.pairType1 Math.Term.piType3) -}
2cd55e395d64924656dd31698e04e052
  sigmaInductor7 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m4, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case Math.Term.$wsigmaInductor2 w of ww { (#,#) ww1 ww2 ->
                 Math.Term.Ap ww1 ww2 }) -}
425ea4bb3db650a28f98735167f0b578
  sigmaInductor8 :: Math.Term.Term
  {- Strictness: x -}
5c5ebad40f9c853927a453718a174363
  sigmaInductor9 :: Math.Term.Term
  {- Strictness: m4,
     Unfolding: (Math.Term.Ap
                   Math.Term.pairType1
                   Math.Term.lambdaType) -}
ebb6ec097144bab7cc4cb9e3b70a19ef
  sigmaType :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (Math.Term.Def
                   Math.Term.sigmaType2
                   Math.Term.sigmaType1) -}
97f6dc7d249c65dc61752e39e1e5aefa
  sigmaType1 :: [Math.Term.Term]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.pairType
                   (GHC.Types.[] @ Math.Term.Term)) -}
1e738084954781ac7791ca15e5c8ffa7
  sigmaType2 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.sigmaType3 Math.Term.U) -}
b056a308be583cc338eb3207bcdc8c32
  sigmaType3 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.sigmaType4 Math.Term.U) -}
89eb7f7b34b7de0a08b4206584bde5c7
  sigmaType4 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Sigma) -}
d437deeadfffa56049c5de6cf965b96e
  subscript :: GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 -> Math.Term.$wsubscript ww1 }) -}
bcf5f4a9c4a005bbdef7518649f696c0
  substitution ::
    Math.Term.Term
    -> Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 3, Strictness: <S,U><S,U><L,U> -}
a017ab0119e2c77c0e545b1cfda4d09a
  subtypes ::
    Math.Term.Context
    -> Math.Term.Term -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ctx :: Math.Term.Context) (t :: Math.Term.Term) ->
                 Math.Term.getRelated Math.Term.SUPERTYPE t ctx) -}
89c2f44b7581b8c66c8bb8e8ab5730ee
  successor :: Math.Term.Term
  {- Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.successor1) -}
1ace83752079e332524d4abbc33fe443
  successor1 :: Math.Term.PrimConst
  {- Strictness: m1,
     Unfolding: (Math.Term.DefConst Math.Term.successor2) -}
ee1094bd18daf2e1d022fdc54224d2cf
  successor2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Math.Term.successor3) -}
e3b03c778ddca6b0166e3f1f8b9a2cca
  successor3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("succ"#) -}
3eb4e01e900367fa938d3792a7146050
  supertypes ::
    Math.Term.Context
    -> Math.Term.Term -> Data.Set.Internal.Set Math.Term.Term
  {- Arity: 2, Strictness: <S(LS),1*U(A,1*U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ctx :: Math.Term.Context) (t :: Math.Term.Term) ->
                 Math.Term.getRelated Math.Term.SUBTYPE t ctx) -}
eba07b5ba3dabe01ad4a2fa6a02c6a42
  toIdInd :: Math.Term.Term -> Math.Term.Inductor
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (t :: Math.Term.Term) ->
                 Math.Term.Inductor t (GHC.Base.id @ Math.Term.Term)) -}
c5503ecd4321975077fc9897d8d31029
  true2 :: Math.Term.Term
  {- Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.coprodType4 Math.Term.one) -}
7e09f9b97af660a2245e63b07286561b
  two :: Math.Term.Term
  {- Strictness: m6,
     Unfolding: (Math.Term.Def Math.Term.two4 Math.Term.two1) -}
75b77aa8189a7b0a08d3dea239f25bb8
  two1 :: [Math.Term.Term]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Term
                   Math.Term.two2
                   (GHC.Types.[] @ Math.Term.Term)) -}
efd5fa54ed6920f4acb5175d3728fc74
  two2 :: Math.Term.Term
  {- Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.two3 Math.Term.one) -}
88dab4b4ea19d29e2929206cedf565dd
  two3 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.anyCoprod2 Math.Term.zero) -}
daa02e051c5984aa6a78938e931c0ccb
  two4 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Two) -}
7f0f316e0b6df98645863e59e13feffc
  typeInductor :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.typeInductor1
                   Math.Term.typeReduce) -}
fc29e97542297ec42a28c5269f18356b
  typeInductor1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.typeInductor2 Math.Term.U) -}
a8f8dd9b9d0dcea15431f56f68f0bfe0
  typeInductor2 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term..:1 Math.Term.U) -}
003dd65d1440fd704ef2b266e24dd948
  typeReduce :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>m6, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Math.Term.Term) ->
                 case Math.Term.$wtypeReduce w of ww { (#,#) ww1 ww2 ->
                 Math.Term.Def ww1 ww2 }) -}
b81381cf9317b4514a582b341059be26
  typeReduce1 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <B,1*U>x -}
1754c5ae79beff4a9fd6fd0ff43e47f9
  typeTheory :: Math.Term.InductionTree
  {- Unfolding: (Math.Term.insertAllMT
                   Math.Term.emptyMT
                   Math.Term.typeTheory1) -}
53a0281d8d533762932d5ac13c3dc388
  typeTheory1 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.zeroInductor
                   Math.Term.typeTheory2) -}
2f7b1484d43056964d8c276898629554
  typeTheory10 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.funcElim
                   Math.Term.typeTheory11) -}
cb31ede4a9d67a0823a5aa77e385c06d
  typeTheory11 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.lambdaInductor
                   Math.Term.typeTheory12) -}
ca2a8df92701b623128023cef42aeb3f
  typeTheory12 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.piInductor1
                   Math.Term.typeTheory13) -}
a9459643fdf3b13e798f0cb985e8f6ab
  typeTheory13 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.piInductor2
                   Math.Term.typeTheory14) -}
bef376ff619a052050da1442961dc7fe
  typeTheory14 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.piInductor3
                   Math.Term.typeTheory15) -}
dc274089b4b01046fd4b991dc6023e37
  typeTheory15 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.piInductor4
                   Math.Term.typeTheory16) -}
2ea809135a13626568dd246d0061e812
  typeTheory16 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.sigmaInductor1
                   Math.Term.typeTheory17) -}
a7a2bb09c556f83d2c3ae166aa4962a0
  typeTheory17 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.sigmaInductor2
                   Math.Term.typeTheory18) -}
281bbae732161d4147da2e12a17bc9d5
  typeTheory18 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.sigmaInductor3
                   (GHC.Types.[] @ Math.Term.Inductor)) -}
05b8280f7de4cd9b5e7c5803607e4d43
  typeTheory2 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.oneInductor
                   Math.Term.typeTheory3) -}
d2c69075b2abffda673fedba2a07e78c
  typeTheory3 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.typeInductor
                   Math.Term.typeTheory4) -}
4fd922908514ed7cc1e1a248f4fb332b
  typeTheory4 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.reflectLaw
                   Math.Term.typeTheory5) -}
9ca33a460d715c4c0c5820ad773d3dd5
  typeTheory5 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.identityFunctorLaw1
                   Math.Term.typeTheory6) -}
f8bef264781c82db92fc3e71bfad6aa5
  typeTheory6 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.identityFunctorLaw2
                   Math.Term.typeTheory7) -}
5b3e5296b02a874f5adbe0021eb6d271
  typeTheory7 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.prjLInd
                   Math.Term.typeTheory8) -}
9960cf00186bc4d5965e58673583d64c
  typeTheory8 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.prjRInd
                   Math.Term.typeTheory9) -}
b8282abaf8f2b8119816b8bfe69c2c45
  typeTheory9 :: [Math.Term.Inductor]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Math.Term.Inductor
                   Math.Term.reflElim
                   Math.Term.typeTheory10) -}
ff5a027e483c9e1e5c7e25f16aef05ec
  unary :: Math.Term.PrimConst -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ (p :: Math.Term.PrimConst) (eta :: Math.Term.Term) ->
                 Math.Term.Ap (Math.Term.Prim p) eta) -}
16517797298263de8884065570a7b454
  uniquejoin :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2,
     Strictness: <L,U(A,C(C1(U)),A,A,A,C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dOrd1 :: GHC.Classes.Ord a) (x :: [a]) ->
                 Data.Set.Internal.$fDataSet_go
                   @ a
                   (GHC.Types.[] @ a)
                   (Data.Set.Internal.fromList @ a $dOrd1 x)) -}
d1fd586a61e8a52af39f71d1ed9d5fd8
  uniquesTree ::
    [Data.Tree.Tree Math.Term.Term] -> [Data.Tree.Tree Math.Term.Term]
  {- Arity: 1, Strictness: <S,1*U> -}
c37c95574824a080de7785b7e8287abe
  wild :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Math.Term.wild1) -}
187d24ba0c5671fea1ff5c130d64e872
  wild1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\240\\157\\145\\165"#) -}
f59a183005fcd75b83648c7e0d0a745f
  wildcard :: Math.Term.Term
  {- Strictness: m2, Unfolding: (Math.Term.X Math.Term.wild) -}
aab096371ad3f4c193693ead3c3d025d
  zero :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (Math.Term.Def
                   Math.Term.zero1
                   (GHC.Types.[] @ Math.Term.Term)) -}
c513c389db1604593fffacd503ff4fd5
  zero1 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (Math.Term.Prim Math.Term.Zero) -}
6d46fa90d84ca7efa0011643146c945c
  zeroInductor :: Math.Term.Inductor
  {- Strictness: m,
     Unfolding: (Math.Term.Inductor
                   Math.Term.zeroInductor3
                   Math.Term.zeroInductor1) -}
8827c4a3ecbf926fa39bf7e2211b57ad
  zeroInductor1 :: Math.Term.Term -> Math.Term.Term
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: Math.Term.Term) ->
                 case ds of wild2 {
                   DEFAULT -> Math.Term.zeroInductor2
                   Math.Term.Ap ds1 ds2
                   -> case ds1 of wild3 {
                        DEFAULT -> Math.Term.zeroInductor2
                        Math.Term.Ap ds3 c
                        -> case ds3 of wild4 {
                             DEFAULT -> Math.Term.zeroInductor2
                             Math.Term.Prim ds4
                             -> case ds4 of wild5 {
                                  DEFAULT -> Math.Term.zeroInductor2
                                  Math.Term.Pi
                                  -> case ds2 of wild6 {
                                       DEFAULT -> Math.Term.zeroInductor2
                                       Math.Term.Def ds5 ds6
                                       -> case ds5 of wild7 {
                                            DEFAULT -> Math.Term.zeroInductor2
                                            Math.Term.Prim ds7
                                            -> case ds7 of wild8 {
                                                 DEFAULT -> Math.Term.zeroInductor2
                                                 Math.Term.Zero
                                                 -> case ds6 of wild9 {
                                                      [] -> c
                                                      : ipv ipv1
                                                      -> Math.Term.zeroInductor2 } } } } } } } }) -}
3e8d9d6ae069117a5237b7ed257e5b3b
  zeroInductor2 :: Math.Term.Term
  {- Strictness: x -}
1df7eb77972616d443483905ab1dab23
  zeroInductor3 :: Math.Term.Term
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Math.Term.Ap Math.Term.piType4 Math.Term.zero) -}
0c0a0001df27ffbb14ea5da134d08b82
  (|->) :: Math.Term.Term -> Math.Term.Term -> Math.Term.Term
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True) Math.Term.bind -}
instance [safe] GHC.Classes.Eq [Math.Term.Inductor]
  = Math.Term.$fEqInductor
instance [safe] GHC.Classes.Eq [Math.Term.PrimConst]
  = Math.Term.$fEqPrimConst
instance [safe] GHC.Classes.Eq [Math.Term.Term]
  = Math.Term.$fEqTerm
instance [safe] GHC.Classes.Eq [Math.Term.TypeRel]
  = Math.Term.$fEqTypeRel
instance [safe] GHC.Base.Monoid [Math.Term.Context]
  = Math.Term.$fMonoidContext
instance [safe] GHC.Base.Monoid [Math.Term.Term]
  = Math.Term.$fMonoidTerm
instance [safe] GHC.Classes.Ord [Math.Term.Inductor]
  = Math.Term.$fOrdInductor
instance [safe] GHC.Classes.Ord [Math.Term.PrimConst]
  = Math.Term.$fOrdPrimConst
instance [safe] GHC.Classes.Ord [Math.Term.Term]
  = Math.Term.$fOrdTerm
instance [safe] GHC.Classes.Ord [Math.Term.TypeRel]
  = Math.Term.$fOrdTypeRel
instance [safe] GHC.Base.Semigroup [Math.Term.Context]
  = Math.Term.$fSemigroupContext
instance [safe] GHC.Base.Semigroup [Math.Term.InductionTree]
  = Math.Term.$fSemigroupInductionTree
instance [safe] GHC.Base.Semigroup [Math.Term.Term]
  = Math.Term.$fSemigroupTerm
instance [safe] GHC.Show.Show [Math.Term.Context]
  = Math.Term.$fShowContext
instance [safe] GHC.Show.Show [Math.Term.InductionTree]
  = Math.Term.$fShowInductionTree
instance [safe] GHC.Show.Show [Math.Term.Inductor]
  = Math.Term.$fShowInductor
instance [safe] GHC.Show.Show [Math.Term.PrimConst]
  = Math.Term.$fShowPrimConst
instance [safe] GHC.Show.Show [Math.Term.Term]
  = Math.Term.$fShowTerm
instance [safe] GHC.Show.Show [Math.Term.TypeRel]
  = Math.Term.$fShowTypeRel
"SPEC setconcat @ Term" forall ($dOrd1 :: GHC.Classes.Ord
                                            Math.Term.Term)
  Math.Term.setconcat @ Math.Term.Term $dOrd1
  = Math.Term.setconcat_$ssetconcat
"SPEC/Math.Term $fEqTree @ Term" forall (v :: GHC.Classes.Eq
                                                Math.Term.Term)
  Data.Tree.$fEqTree @ Math.Term.Term v = Math.Term.$s$fEqTree
"SPEC/Math.Term $fEqTree_$c/= @ Term" forall ($dEq :: GHC.Classes.Eq
                                                        Math.Term.Term)
  Data.Tree.$fEqTree_$c/= @ Math.Term.Term $dEq
  = Math.Term.$s$fEqTree_$s$fEqTree_$c/=
"SPEC/Math.Term $wsplitS @ Term" [2] forall (w :: GHC.Classes.Ord
                                                    Math.Term.Term)
  Data.Set.Internal.$wsplitS @ Math.Term.Term w
  = Math.Term.$s$wsplitS
"SPEC/Math.Term difference @ Term" forall ($dOrd1 :: GHC.Classes.Ord
                                                       Math.Term.Term)
  Data.Set.Internal.difference @ Math.Term.Term $dOrd1
  = Math.Term.$sdifference
"SPEC/Math.Term fromList @ Inductor" forall ($dOrd1 :: GHC.Classes.Ord
                                                         Math.Term.Inductor)
  Data.Set.Internal.fromList @ Math.Term.Inductor $dOrd1
  = Math.Term.$fMonoidContext_$sfromList
"SPEC/Math.Term fromList @ Term" forall ($dOrd1 :: GHC.Classes.Ord
                                                     Math.Term.Term)
  Data.Set.Internal.fromList @ Math.Term.Term $dOrd1
  = Math.Term.$sfromList
"SPEC/Math.Term union @ (Term, TypeRel)" forall ($dOrd1 :: GHC.Classes.Ord
                                                             (Math.Term.Term, Math.Term.TypeRel))
  Data.Set.Internal.union @ (Math.Term.Term, Math.Term.TypeRel)
                          $dOrd1
  = Math.Term.$sunion
"SPEC/Math.Term union @ Term" forall ($dOrd1 :: GHC.Classes.Ord
                                                  Math.Term.Term)
  Data.Set.Internal.union @ Math.Term.Term $dOrd1
  = Math.Term.$fMonoidContext_$sunion
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

